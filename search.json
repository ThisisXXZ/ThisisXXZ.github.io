[{"title":"Day 1","path":"/diary-break/db-day-1/","content":""},{"title":"Stellar 魔改小记录","path":"/adapt-stellar/","content":"趁着开学事情不多，好好折腾了一下这个新玩具主题，简直有点到爱不释手的地步了。记录一下魔改的过程，以供自鉴；如果能帮到有类似需求的朋友们就更好啦！ 你好 Stellar！ 博客组织方式之我思众所周知 Stellar 最吸引人的特性之一是强大的 Wiki 文档系统，但一番操作发现并不是所有的文章都适合用 Wiki 进行组织。 向 Wiki 项目中添加文章的过程有点繁琐，得改目录树。 Wiki 项目中的文章居然不在主页显示！即是说假如我的某篇得意之作被收录在 Wiki 项目里，我就无法在主页展示出来；这要求我必须在我的强迫症和虚荣心中舍彼取此。当然有一个方法是项目 wiki/[project] 里收录一篇，再复制一篇到主页 _post，但这个解法实在是太丑陋。 某些主题不明确的文章不适合收到一个集子里。本来打算是专门弄一个「其他」项目，但仔细想想假以时日这个「其他」一定会膨胀到难以忽视。 我仔细审视了一下我的博客内容，大概分成四类。 从左到右从上往下分别记为 A/B/C/D 类型内容 首先 A 型内容很适合做成 Wiki 项目。一方面它们已经成型，后续的增补内容很少；另一方面它们大多数是作为有机整体的课程笔记系列，不太有机会需要单拎一篇出来放到主页。 而 B 型内容多数是散乱的课程笔记/自学记录，质量良莠不齐，显然我想要展示一部分，隐藏一部分；但被隐藏的内容并不代表没有价值，我还是需要挂在博客上供我自己参考回顾，只是我个人并不是特别满意罢了。 C 型内容是我的读书/观影/游戏记录，以时间为经连缀起我的精神生活碎片，显然是需要不断增补更新的。并且这其中有一些认真写的书评&#x2F;影评&#x2F;游戏评，是我想放在主页上展示的。 最后的 D 型内容是我日常的一些文字随笔，没有特定主题，也无需时间串联，整个形式是十分随意的，但这一部分却是我很想展示在主页的内容。 哇！简直乱糟糟！不仅每种内容的组织形式不同，结构完整度不同，我想要展示的欲望也不同！而当中仅仅只有需求 A 是原生 Stellar 可以解决的！如果谁能想到办法四个需求一次满足的话，那 TA 一定是天才了吧！ 我们需要「专栏」！还好！Stellar 提供了一种有别于 Wiki 项目的简化组织形式 —— 专栏，这让我的大业又推进了一步。 简而言之，「专栏」就是没有目录树的 Wiki 项目，其单纯的以时间为索引松散的连缀一系列指定主题的文章。但这同时引入了一个新问题：专栏没有 index 页，每次点进去默认显示的都是最新的文章，而我想要的是一个类似目录或者扉页的东西。 Wiki 项目能够很容易的实现这一点，只要建一个 index 并把它指定为目录树的开头就行。真是成也目录树，败也目录树！ 为了解决这个问题，我定义了一个新的 front-matter 字段：topic_pin： themes/stellar/scripts/events/lib/merge_posts.js1234567891011121314151617181920for (let tid of Object.keys(topic.tree)) &#123; let topicObject = topic.tree[tid] const pinnedPages = topicObject.pages.filter( page =&gt; page.topic_pin === true) const normalPages = topicObject.pages.filter( page =&gt; page.topic_pin !== true) if (topicObject.order_by == &#x27;-date&#x27;) &#123; pinnedPages.sort((a, b) =&gt; new Date(b.date) - new Date(a.date)) normalPages.sort((a, b) =&gt; new Date(b.date) - new Date(a.date)) &#125; else &#123; pinnedPages.sort((a, b) =&gt; new Date(a.date) - new Date(b.date)) normalPages.sort((a, b) =&gt; new Date(a.date) - new Date(b.date)) &#125; topicObject.pages = [...pinnedPages, ...normalPages] topicObject.homepage = topicObject.pages[0]&#125; 在专栏中创建一个 index 页，再在 front-matter 中设置 topic_pin: true 就大功告成啦！ ……把思路逆转过来！试着把 B 型内容和 C 型内容用改良后的专栏来组织，效果很好！在此期间还发现一件有趣的事：由于专栏不要求 markdown 文件存储在 _post 之外，收录不收录到专栏并不影响文章本身在主页上的显示。 之前研究 Wiki 项目产生了惯性思维，一直在想怎样把项目内的亮点文章挪到主页来显示；没想到专栏的这个特性使得需求逆转了：现在需要考虑的是如何隐藏某些在主页的非亮点文章了。 等等！这不是我在老博客中使用过的 hexo-hide-posts 插件吗！ 激动的配置好这个插件，隐藏文章 —— 果然没我想象的那么简单。Stellar 的 topic 并不是一个常规的 generator，不能直接写在白名单里；这就是说当我在主页隐藏某个文章的同时，这个文章同时也在专栏中被隐藏了。 好嘛！到头来还是逆转回去了。异议阿里！ 只好想了个折衷的办法，虽然逆转再逆转的思路确实不太优雅，但实现起来却很简洁（毕竟插件把大部分逻辑都抽象好了，不用白不用）： themes/stellar/scripts/filters/topic_hidden_handler.js12345678910111213141516hexo.extend.filter.register(&#x27;before_generate&#x27;, function() &#123; const hexo = this; const PostModel = hexo.database.model(&#x27;Post&#x27;); const allPosts = PostModel.toArray(); const hiddenTopicPosts = allPosts.filter(post =&gt; post.hidden === true &amp;&amp; post.topic &amp;&amp; post.topic.length &gt; 0 ); if (hiddenTopicPosts.length &gt; 0) &#123; hexo.locals.set(&#x27;hidden_topic_posts&#x27;, function() &#123; return hiddenTopicPosts; &#125;); &#125;&#125;); 这个 handler 会在 hexo-hide-posts 作用之前收集所有被 hidden: true 标记的文章，并在之后 merge_posts.js 脚本收集专栏文章的时候返还 hiddenTopicPosts 中对应专栏的隐藏文章。天哪说起来都好绕。 最终效果见我的专栏，你会发现不是所有的专栏文章都会显示在主页上喔。是不是很不错！ 静态 timeline 标签组件化之前提到，C 型内容是根据时间组织的，而 Stellar 正好提供了「时间线」组件，非常契合我的需求。我想在 C 型内容首页的右侧边栏挂上时间线，每次读完一本新书，打完一部游戏，就能往上串一条新的经历，多有满足感！ 探索时间线标签的 N 种用法https://xaoxuu.com/blog/20221029/ 但事情比我想象中的棘手。仔细阅读完教程后我发现，「时间线」实际上有两种： 静态时间线：放在正文部分，是一个 &#123;% timeline %&#125; 标签，内容是写死在 markdown 里的。 动态时间线：这才是侧边栏组件，需要配置 API 从其他地方提取动态数据；但这不是我想要的。 我的需求是把静态时间线配置到侧边栏组件上，这一点原生 Stellar 并不支持。 又注意到侧边栏组件中有一个叫 markdown 的，非常的灵活，支持在侧边栏显示任意形式的 markdown 语法文本。尝试将 &#123;% timeline %&#125; 标签写进去，果然不渲染。 那么我们让它渲染不就行了嘛！照猫画虎根据 markdown 组件的逻辑扩展了 timeline 组件，新增 content 字段，并且以有无 api 字段决定是动态还是静态时间线。 核心修改逻辑themes\\stellar\\layout\\_partial\\widgets\\timeline.ejs1234567891011121314151617181920212223242526272829303132333435363738if (item.api) &#123; el += `&lt;div class=&quot;tag-plugin timeline data-service ds-$&#123;(item.type || &#x27;timeline&#x27;)&#125;&quot;`; [&#x27;api&#x27;].forEach(key =&gt; &#123; if (item[key]) &#123; el += &#x27; data-&#x27; + key + &#x27;=&quot;&#x27; + item[key] + &#x27;&quot;&#x27;; &#125; &#125;); [&#x27;user&#x27;, &#x27;hide&#x27;, &#x27;limit&#x27;].forEach(key =&gt; &#123; if (item[key]) &#123; el += &#x27; &#x27; + key + &#x27;=&quot;&#x27; + item[key] + &#x27;&quot;&#x27;; &#125; &#125;); el += &#x27;&gt;&#x27;; el += &#x27;&lt;/div&gt;&#x27;;&#125; else &#123; el += &#x27;&lt;div class=&quot;tag-plugin timeline data-service ds-timeline&quot;&gt;&#x27;; if (item.content) &#123; if (item.content.includes(&#x27;&lt;!-- node&#x27;)) &#123; var nodes = parseStaticTimelineNodes(item.content); nodes.forEach((node, i) =&gt; &#123; el += &#x27;&lt;div class=&quot;timenode&quot; index=&quot;&#x27; + i + &#x27;&quot;&gt;&#x27;; el += &#x27;&lt;div class=&quot;header&quot;&gt;&#x27;; el += node.header; el += &#x27;&lt;/div&gt;&#x27;; el += &#x27;&lt;div class=&quot;body fs14&quot;&gt;&#x27;; el += markdown(node.body); el += &#x27;&lt;/div&gt;&#x27;; el += &#x27;&lt;/div&gt;&#x27;; &#125;); &#125; else &#123; el += &#x27;&lt;div class=&quot;timenode&quot; index=&quot;0&quot;&gt;&#x27;; el += &#x27;&lt;div class=&quot;header&quot;&gt;Content&lt;/div&gt;&#x27;; el += &#x27;&lt;div class=&quot;body fs14&quot;&gt;&#x27;; el += markdown(item.content); el += &#x27;&lt;/div&gt;&#x27;; el += &#x27;&lt;/div&gt;&#x27;; &#125; &#125; el += &#x27;&lt;/div&gt;&#x27;;&#125; 还得小修一下 themes\\stellar\\source\\css\\_components\\widgets\\timeline.styl 使得静态时间线组件的标题与内容排列更加紧凑，比较繁琐，故按下不表。 你可以去探索页，书&#x2F;影&#x2F;游戏评主页的右侧边栏看到实现的效果。是不是挺像那么回事的？ Giscus 评论区主题自定义之前的老博客用的是早已停止开源的 Valine，听说还有隐私泄露的风险，所以趁着升级博客把评论系统也给换一换（之前的评论都要无了 555）。 Giscus 基于 Github Discussion 来做映射简直是一个天才般的想法，配置起来也无比的简单，就是可能对没有 Github 账号的朋友不太友好。 除此之外还有一个让我强迫症发作的点在于 Giscus 组件是一个 iframe，不受我博客的 CSS 样式管辖，这就造成我没法在评论区用上美丽的落霞孤鹜字体。 研究了一下，成功用 Giscus 提供的自定义主题接口解决了，顺便还调整了一下边框样式，加了夜间模式。有需要的朋友可以在 这里 自取我的样式文件，直接托管到你自己的网站上再修改 Giscus 的 data-theme 字段就好啦！记得 url 不要加 www 前缀，不然会 CORS。 其他想要做的事 O1 完成博客从 NexT.Pisces 到 Stellar 的迁移！ 计划在学期内结束。 正常 40% KR1 定义并实现所有博客内容的组织形式 定义博客内容组织形式新增专栏目录页支持新增专栏文章主页隐藏功能 已完成 100% KR2 迁移旧博客上的所有博文 计划顺序：D &#x3D;&gt; C &#x3D;&gt; B &#x3D;&gt; A 未完成 10% KR3 其他想要的小特性！ 静态 timeline 标签组件化giscus 评论区换成 LXGW 字体加入「开往」独立博客计划为读书/观影/游戏记录页添加类似豆瓣的封面展示集成 hexo-blog-encrypt 插件实现部分贴文的密码访问研究怎样把本地资源远程托管 未完成 10%"},{"title":"序","path":"/review-game/index/","content":""},{"title":"序","path":"/review-film/index/","content":""},{"title":"《人生的智慧》","path":"/review-book/wisdom-of-life/","content":"简评"},{"title":"《自报家门》","path":"/review-book/zibao-jiamen/","content":"简评摘录"},{"title":"《理想国》","path":"/review-book/the-republic/","content":"简评摘录"},{"title":"《众神的战争：希腊神话与西方艺术》","path":"/review-book/zhongshen-dezhan/","content":"简评"},{"title":"《金阁寺》","path":"/review-book/kinkaku-ji/","content":"简评"},{"title":"序","path":"/review-book/index/","content":""},{"path":"/css/giscus-custom.css","content":"@import url(https://gcore.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.7/lxgwwenkaigbscreen.css); @import url(https://gcore.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.7/lxgwwenkaigbscreenr.css); @import url(https://gcore.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.7/lxgwwenkaiscreen.css); @import url(https://gcore.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.7/lxgwwenkaiscreenr.css); html { font-family: 'LXGW WenKai Screen',system-ui,sans-serif !important; text-rendering: optimizelegibility; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } #__next main .link-secondary { text-decoration-line: unset; } #__next main .underline { text-decoration-line: unset; } #__next main .markdown a { text-decoration-line: unset; } main { --primary-default: 5, 92, 55; --bg-default: 246, 246, 247; --color-prettylights-syntax-comment: #6e7781; --color-prettylights-syntax-constant: #0550ae; --color-prettylights-syntax-entity: #8250df; --color-prettylights-syntax-storage-modifier-import: #24292f; --color-prettylights-syntax-entity-tag: #116329; --color-prettylights-syntax-keyword: #cf222e; --color-prettylights-syntax-string: #0a3069; --color-prettylights-syntax-variable: #953800; --color-prettylights-syntax-brackethighlighter-unmatched: #82071e; --color-prettylights-syntax-invalid-illegal-text: #f6f8fa; --color-prettylights-syntax-invalid-illegal-bg: #82071e; --color-prettylights-syntax-carriage-return-text: #f6f8fa; --color-prettylights-syntax-carriage-return-bg: #cf222e; --color-prettylights-syntax-string-regexp: #116329; --color-prettylights-syntax-markup-list: #3b2300; --color-prettylights-syntax-markup-heading: #0550ae; --color-prettylights-syntax-markup-italic: #24292f; --color-prettylights-syntax-markup-bold: #24292f; --color-prettylights-syntax-markup-deleted-text: #82071e; --color-prettylights-syntax-markup-deleted-bg: #ffebe9; --color-prettylights-syntax-markup-inserted-text: #116329; --color-prettylights-syntax-markup-inserted-bg: #dafbe1; --color-prettylights-syntax-markup-changed-text: #953800; --color-prettylights-syntax-markup-changed-bg: #ffd8b5; --color-prettylights-syntax-markup-ignored-text: #eaeef2; --color-prettylights-syntax-markup-ignored-bg: #0550ae; --color-prettylights-syntax-meta-diff-range: #8250df; --color-prettylights-syntax-brackethighlighter-angle: #57606a; --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f; --color-prettylights-syntax-constant-other-reference-link: #0a3069; --color-btn-text: #24292f; --color-btn-bg: rgba(var(--bg-default), 1); --color-btn-border: rgba(var(--bg-default), 1); --color-btn-shadow: 0 1px 0 rgba(var(--bg-default), 1); --color-btn-inset-shadow: inset 0 1px 0 rgba(var(--bg-default), 1); --color-btn-hover-bg: rgba(var(--bg-default), 0.5); --color-btn-hover-border: rgba(var(--bg-default), 0.5); --color-btn-active-bg: rgba(var(--primary-default), 0.2); --color-btn-active-border: rgba(var(--primary-default), 1); --color-btn-selected-bg: rgba(var(--primary-default), 0.15); --color-btn-primary-text: rgb(255 255 255 / 100%); --color-btn-primary-bg: rgba(var(--primary-default), 1); --color-btn-primary-border: rgba(var(--primary-default), 1); --color-btn-primary-shadow: 0 1px 0 rgb(31 35 40 / 10%); --color-btn-primary-inset-shadow: inset 0 1px 0 rgb(255 255 255 / 3%); --color-btn-primary-hover-bg: rgba(var(--primary-default), 0.9); --color-btn-primary-hover-border: rgba(var(--primary-default), 0.75); --color-btn-primary-selected-bg: rgba(var(--primary-default), 1); --color-btn-primary-selected-shadow: inset 0 1px 0 rgb(0 45 17 / 20%); --color-btn-primary-disabled-text: rgb(255 255 255 / 80%); --color-btn-primary-disabled-bg: rgba(var(--primary-default), 0.5); --color-btn-primary-disabled-border: rgba(var(--primary-default), 0.5); --color-action-list-item-default-hover-bg: rgb(208 215 222 / 32%); --color-segmented-control-bg: #eaeef2; --color-segmented-control-button-bg: #fff; --color-segmented-control-button-selected-border: rgba(var(--bg-default), 0.85); --color-fg-default: rgb(60 60 67); --color-fg-muted: rgb(60 60 67 / 75%); --color-fg-subtle: rgb(60 60 67 / 33%); --color-canvas-default: rgb(255 255 255); --color-canvas-overlay: rgb(255 255 255); --color-canvas-inset: rgba(var(--bg-default), 0.85); --color-canvas-subtle: rgba(var(--bg-default), 1); --color-border-default: rgba(var(--bg-default), 0.85); --color-border-muted: rgb(175 184 193 / 20%); --color-neutral-muted: rgb(175 184 193 / 20%); --color-accent-fg: rgba(var(--primary-default), 0.85); --color-accent-emphasis: rgba(var(--primary-default), 0.95); --color-accent-muted: rgba(var(--primary-default), 0.4); --color-accent-subtle: rgba(var(--primary-default), 0.1); --color-success-fg: #1a7f37; --color-attention-fg: #9a6700; --color-attention-muted: rgb(212 167 44 / 40%); --color-attention-subtle: #fff8c5; --color-danger-fg: #d1242f; --color-danger-muted: rgb(255 129 130 / 40%); --color-danger-subtle: #ffebe9; --color-primer-shadow-inset: 0 1px 0 rgba(var(--bg-default), 1), inset 0 1px 0 rgba(var(--bg-default), 1); --color-scale-gray-1: rgb(234 238 242 / 100%); --color-scale-blue-1: rgb(16 185 129 / 15%); /*! Extensions from @primer/css/alerts/flash.scss */ --color-social-reaction-bg-hover: var(--color-scale-gray-1); --color-social-reaction-bg-reacted-hover: var(--color-scale-blue-1); } main .pagination-loader-container { background-image: url(\"https://github.com/images/modules/pulls/progressive-disclosure-line.svg\"); } main .gsc-loading-image { background-image: url(\"https://github.githubassets.com/images/mona-loading-default.gif\"); } .gsc-comment:not(.gsc-reply-box) .gsc-replies { border-radius: unset; } /* Dark mode overrides for giscus (system/browser dark) */ @media (prefers-color-scheme: dark) { main { --primary-default: 20, 222, 155; --bg-default: 22, 22, 24; --color-prettylights-syntax-comment: #8b949e; --color-prettylights-syntax-constant: #79c0ff; --color-prettylights-syntax-entity: #d2a8ff; --color-prettylights-syntax-storage-modifier-import: #c9d1d9; --color-prettylights-syntax-entity-tag: #7ee787; --color-prettylights-syntax-keyword: #ff7b72; --color-prettylights-syntax-string: #a5d6ff; --color-prettylights-syntax-variable: #ffa657; --color-prettylights-syntax-brackethighlighter-unmatched: #f85149; --color-prettylights-syntax-invalid-illegal-text: #f0f6fc; --color-prettylights-syntax-invalid-illegal-bg: #8e1519; --color-prettylights-syntax-carriage-return-text: #f0f6fc; --color-prettylights-syntax-carriage-return-bg: #b62324; --color-prettylights-syntax-string-regexp: #7ee787; --color-prettylights-syntax-markup-list: #f2cc60; --color-prettylights-syntax-markup-heading: #1f6feb; --color-prettylights-syntax-markup-italic: #c9d1d9; --color-prettylights-syntax-markup-bold: #c9d1d9; --color-prettylights-syntax-markup-deleted-text: #ffdcd7; --color-prettylights-syntax-markup-deleted-bg: #67060c; --color-prettylights-syntax-markup-inserted-text: #aff5b4; --color-prettylights-syntax-markup-inserted-bg: #033a16; --color-prettylights-syntax-markup-changed-text: #ffdfb6; --color-prettylights-syntax-markup-changed-bg: #5a1e02; --color-prettylights-syntax-markup-ignored-text: #c9d1d9; --color-prettylights-syntax-markup-ignored-bg: #1158c7; --color-prettylights-syntax-meta-diff-range: #d2a8ff; --color-prettylights-syntax-brackethighlighter-angle: #8b949e; --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58; --color-prettylights-syntax-constant-other-reference-link: #a5d6ff; --color-btn-text: rgb(235 235 245 / 86%); --color-btn-bg: rgba(var(--bg-default), 1); --color-btn-border: rgba(var(--bg-default), 1); --color-btn-shadow: 0 1px 0 rgba(var(--bg-default), 1); --color-btn-inset-shadow: inset 0 1px 0 rgba(var(--bg-default), 1); --color-btn-hover-bg: rgba(var(--bg-default), 0.5); --color-btn-hover-border: rgba(var(--bg-default), 0.5); --color-btn-active-bg: rgba(var(--primary-default), 0.2); --color-btn-active-border: rgba(var(--primary-default), 1); --color-btn-selected-bg: rgba(var(--primary-default), 0.15); --color-btn-primary-text: rgb(255 255 255 / 100%); --color-btn-primary-bg: rgba(var(--primary-default), 0.45); --color-btn-primary-border: rgba(var(--primary-default), 0.5); --color-btn-primary-shadow: 0 1px 0 rgb(27 31 36 / 10%); --color-btn-primary-inset-shadow: inset 0 1px 0 hsl(0deg 0% 100% / 3%); --color-btn-primary-hover-bg: rgba(var(--primary-default), 0.53); --color-btn-primary-hover-border: rgba(var(--primary-default), 0.75); --color-btn-primary-selected-bg: rgba(var(--primary-default), 0.45); --color-btn-primary-selected-shadow: inset 0 1px 0 rgb(0 45 17 / 20%); --color-btn-primary-disabled-text: rgb(255 255 255 / 80%); --color-btn-primary-disabled-bg: rgba(var(--primary-default), 0.5); --color-btn-primary-disabled-border: rgba(var(--primary-default), 0.5); --color-action-list-item-default-hover-bg: rgb(177 186 196 / 12%); --color-segmented-control-bg: rgb(110 118 129 / 10%); --color-segmented-control-button-bg: #0d1117; --color-segmented-control-button-selected-border: rgba(var(--bg-default), 0.85); --color-fg-default: rgb(235 235 245 / 86%); --color-fg-muted: rgb(235 235 245 / 60%); --color-fg-subtle: rgb(235 235 245 / 50%); --color-canvas-default: rgb(30 30 32 / 100%); --color-canvas-overlay: rgb(30 30 32 / 100%); --color-canvas-inset: rgba(var(--bg-default), 0.85); --color-canvas-subtle: rgba(var(--bg-default), 1); --color-border-default: rgba(var(--bg-default), 0.85); --color-border-muted: rgb(175 184 193 / 20%); --color-neutral-muted: rgb(175 184 193 / 20%); --color-accent-fg: rgba(var(--primary-default), 0.85); --color-accent-emphasis: rgba(var(--primary-default), 0.95); --color-accent-muted: rgba(var(--primary-default), 0.4); --color-accent-subtle: rgba(var(--primary-default), 0.1); --color-success-fg: #3fb950; --color-attention-fg: #d29922; --color-attention-muted: rgb(187 128 9 / 40%); --color-attention-subtle: rgb(187 128 9 / 15%); --color-danger-fg: #f85149; --color-danger-muted: rgb(248 81 73 / 40%); --color-danger-subtle: rgb(248 81 73 / 10%); --color-primer-shadow-inset: 0 1px 0 rgba(var(--bg-default), 1), inset 0 1px 0 rgba(var(--bg-default), 1); --color-scale-gray-7: rgb(22 22 24 / 100%); --color-scale-blue-8: rgb(16 185 129 / 15%); /*! Extensions from @primer/css/alerts/flash.scss */ --color-social-reaction-bg-hover: var(--color-scale-gray-7); --color-social-reaction-bg-reacted-hover: var(--color-scale-blue-8); } main .pagination-loader-container { background-image: url(\"https://github.com/images/modules/pulls/progressive-disclosure-line-dark.svg\"); } main .gsc-loading-image { background-image: url(\"https://github.githubassets.com/images/mona-loading-dark.gif\"); } }"},{"title":"基本原语","path":"/wiki/note-cryptography/cryptographic-primitives.html","content":"Cryptographic PrimitivesCryptographic primitives are well-established, low-level cryptographic algorithms that are frequently used to build cryptographic protocols for computer security systems. In this course, 7 kinds of cryptographic primitives are covered: Encryption scheme Message authentication code (MAC) Hash function Key-exchange protocol Identification scheme Digital signature One-way function In different application scenarios, we need different kinds of security: Confidentiality: only trusted party could understand the secret message. Secure encryption scheme provides confidentiality. Integrity: ensures the information has NOT been tampered in transmission. MAC and digital signature provide integrity. Non-repudiation: sender can NOT later deny that the message was sent. Digital signature provides non-repudiation. Authenticity, Public verifiability, transferability… Also, for a cryptographic primitive, the definition of security varies in face of different threat model. Threat model consists of the adversary and his targets of attack.In stronger notions of security, adversary tends to have more power, therefore cryptographic primitives with stronger definitions are more secure than weak ones. In general, the security of a cryptographic primitive is defined by an experiment (or game). The idea of reduction (归约) is critical in designing such experiments. Encryption scheme: Passive eavesdropping (EAV) security, Chosen-plaintext-attack (CPA) security, Chosen-ciphertext-attack (CCA) security, Perfect secrecy Message authentication code (MAC): Extentially unforgeable under a chosen-message attack Hash function: Preimage resistance, Second-preimage resistance, Collision resistance Key-exchange protocol: EAV security Identification scheme: EAV security Digital signature: Extentially unforgeable under a chosen-message attack One-way function: Non-invertibility"},{"title":"explore","path":"/explore/index.html","content":"UN JOUR JE SERAI DE RETOUR PRÈS DE TOI 这里是？茫茫电子之海中最不起眼的一隅；即使是这样的角落也有千千万万个。 但它的的确确完全属于*此人*。 此人是？一个傲慢、冷漠、自我中心、缺乏个性的人。总而言之，是一个*无趣*的人。 那么又有什么必要在这停留呢？简而言之，他正在经历一个十分特殊的阶段：即，他意识到自己有多么的无趣。 我很了解此人，或者说，像他这类的人。他们虽然常常将「我是个普通人」挂在嘴边，但心底里却丝毫不这么觉得。「毕竟，一个真正的普通人怎么会承认自己只是一个普通人呢？」他们会沾沾自喜地反刍自己的谦虚，脸上现出甜腻的傻笑。 你会发现他们生活在镜像迷宫里，每面镜子都照出他们的幻想。傲慢被映成自信，冷漠被映成理智，自私被映成高效，乏味被映成深刻。 你真该看看镜子破碎时他的表情！更好笑的是，他发现自己并不独特这一事件本身，也在无穷的时间内无限的空间里在无数人的身上反复发生，而他只是其中最不起眼的一个而已。 听起来你并不喜欢这个人。恰恰相反。我嘲笑他的愚蠢，却庆幸他的醒悟。 他从某种浑浑噩噩的状态中稍微取得了一点神智（我得说，和他的同龄人相比，这个过程有点太久了），察觉到他一直以来都陷在一个多么可怖而丑陋的泥潭中。而这还只是第一步。会有更多令人绝望的事实等待着他来发现。 我于是邀请你来欣赏他的挣扎。这一定会相当有趣。 并且我几乎可以确信这也是他想要的；他远比自己想象的更需要其他人的认可和关注。不然怎么会写下这一堆矫揉造作的文字，把*我*远远的放置在*他*的位置，再捏造出另外两个人称帮助他面对这个事实？ 我有点受够了。当然，当然，我能理解。你没有义务参与到这出幻想的三人行当中。我承认这非常的莫名其妙。如果我是你，我只会觉得更加困惑和烦躁。作为一个看客，或者只是无意间点进来的人，你不需要经历这些…… 我说过的吧，他的确相当的自我中心，丝毫不顾及其他人的感受。 但也许你会*享受*这些……如果这样的话…… 「这只是你的一厢情愿。这种投射本身就是莫大的冒犯。」 我越界了。我真诚地表示歉意。我能够想象这歉意本身对你而言也无比的诡异。天哪。我又搞砸了。我原本只是想向你介绍这个人的博客而已。我没能守住他膨胀的自我意识，竟让一些影子附在了你身上；而避免发生这种事本来应该是我的责任、我存在于此的理由。 为了弥补，我决定向你介绍一些真正*有趣*的人。他们是这个人的邻人。我可以保证，你会在他们那里找到一些真正的、有教益的乐趣，而不是在这里，在此处，在这个阴暗的台风天吹袭的夜晚，困在我的喃喃自语中，喘不过气………… 回到现实世界！会不会有点用力过猛了？别担心，以上这段文字只是我的胡言乱语而已啦。你也许会有兴趣逛逛下面这些博客；如果想要交换友链，欢迎在这个页面下留言！ 网上邻居 Steevebrine飘过Skyleekqp's worldArca LunarEricSoraJonanthan"},{"title":"序","path":"/wiki/note-cryptography/index.html","content":"引这一学期糊里糊涂选到了 CS 的高阶课 COMP3357，虽然死了很多脑细胞，但是学到了很多。加密学很有意思，Ravi 讲的很好，TA Zhang Chengru 也很认真负责，上起来很有实感。 之前的笔记 (这里) 太全面肯定不会再仔细看了，于是想趁暑假做一个 digest，让未来的自己也能回忆起一些有趣的，令人大呼巧妙 (Eureka!) 的内容。 我打算将 digest 分为 3 parts，p1 将主要介绍加密学概念中的有趣内容；p2 则侧重于数学 (数论，群论) 等知识在加密学中的应用；p3 是对 p2 的延申，将会介绍加密学中的困难问题 (hard problems) 与单向函数 (one-way function)，其与 p2 中的相关知识存在密切的联系。 启中Eng声明：以下内容为作者就有关课程学习期间整理之个人笔记，并不包含、引用或披露任何与该课程作业或考试有关之资料。所有信息仅供个人学习及复习之用。Disclaimer:These notes are the author’s personal study summaries for the course. They do not contain, refer to, or disclose any assignment or examination materials. All information is for individual learning and revision only. 按 课号：COMP3357 教授：Dr. Ravi. Ramanathan 助教：Zhang Chengru 讲义：Introduction to Modern Cryptography (2nd edition), Katz, J. &amp; Lindell, Y., (2015), CRC Press"},{"title":"柯克霍夫原则","path":"/wiki/note-cryptography/kerckhoff-s-principle.html","content":"Kerckhoff’s PrincipleKerckhoff’s principle is the concept that a Cryptographic system should be designed to be secure, even if all its details, except for the key, are publicly known. Kerckhoff’s principle indicates that the unknowability of secret key $k$ is critical to ensure the security of cryptographic primitive. This principle also makes the storage and transmission of keys extremely important. Eureka&nbsp;moment!第一次学习柯克霍夫定律的时候确实有点惊艳的感觉：一个安全的加密方案竟然必须建立在其所有细节向敌手暴露的前提之下。尽管看上去有点反常识，仔细想想却是有道理的；如果连加密方案本身都需要进行保密，那它的应用价值将大大减少，更遑论加密算法的标准化与通用化了。 而且由此可见现在流行的加密方案都是久经考验的：想象一下，由于算法的所有细节都是公开的知识，一定会有无数人尝试去破解；一个加密方案能够稳定的存在，这一事实本身就能证明其安全性。"},{"title":"伪随机性","path":"/wiki/note-cryptography/pseudorandomness.html","content":"PseudorandomnessRandomness is a very important concept in cryptography (and not only in cryptography). Although the concept of randomness is often mentioned, what exactly is randomness and how is it implemented? Our understanding of the concept of “randomness” cannot be separated from the physical phenomena in real life. For example, the sequence of numbers obtained by rolling a six-sided die multiple times is clearly “random”; this randomness, guaranteed by physical experiments, is called True randomness. True random number generation is technically demanding and inefficient: a true random number generator (TRNG) must rely on some random external physical phenomenon as the information entropy resource, such as the trajectory of the user’s mouse movement, thermal noise from resistors and oscillators, computer hardware noise, etc. NO pure algorithms could achieve true randomness.Here, pure algorithms are the algorithms that only use designed mathmatical formulaes or precalculated tables to produce number suquence. TRNGs that generate random numbers with the help of external physical phenomenon is inefficient. Only pure algorithm could meet the requirement of producing many numbers efficiently. Therefore, the concept of pseudorandomness is put forward: Pseudorandom numbers are numbers that appear random. Pseudorandom number generators (PRGs) are the generators that efficiently generate pseudorandom number sequence. PRG takes a short seed $s$ and produces a pseudorandom string $G(s)$. Pseudorandomness is the relaxation of true randomness.We could say that pseudorandomness is equivalent to true randomness in probablistic polynomial time (PPT) background. How to define “appear random”? There are several PPT statistical tests that used to check whether a number sequence is statistical independent or not. If a number sequence could pass all the statistical tests, it is regarded as random, no matter it is generated by TRNGs or PRGs. Essentially, pseudorandom number sequence (or say PRGs) is deterministic : for a fixed seed $s$, $G(s)$ always remains the same. However, if an adversary observing $G(s)$ without knowing the seed $s$, he can NOT distinguish $G(s)$ from a truly random number sequence $r$ with non-negligible advantage. We could see that in the definition of PRGs: $G$ is a PRG if for every PPT distinguisher $D$, $|\\Pr_{s\\leftarrow U_n}[D(G(s))&#x3D;1]-\\Pr_{r\\leftarrow U_{p(n)}}[D(r)&#x3D;1]|\\leq \\varepsilon(n)$. Note that $p(n)$ is the expansion factor of PRG: $G$ expands the seed $s$ ($|s|&#x3D;n$) to $G(s)$ ($|G(s)|&#x3D;p(n)$) Eureka&nbsp;moment!伪随机也是我觉得十分巧妙的一个概念。 其实，本质上来说，伪随机和加密十分相似。加密算法通过密钥 $k$ 的不可知性保证密文 $c$ 的不可解读性；而伪随机数生成器则通过种子 $s$ 的不可知性保证生成的数串 $G(s)$ 的 (伪) 随机性。 这也可以说是柯克霍夫定律威力的延伸体现。"},{"title":"随机算法","path":"/wiki/note-cryptography/randomized-algorithm.html","content":"Randomized AlgorithmA randomized algorithm uses a source of (pseudo) randomness as part of its logic. Randomized algorithm, as opposed to deterministic algorithm, mapping the same input to several random outputs. The randomness is guaranteed by some random tapes implemented by TRNGs, PRGs, PRFs or PRPs. Randomized algorithms are essential to build secure cryptographic primitives: in particular, Any CPA-secure encryption scheme must be randomized. Chosen-plaintext attack (CPA): Adversary holds the encryption oracle $Enc_k(\\cdot)$, which means he is able to obtain any ciphertext $c$ for a desired message $m$ without knowing secret key $k$. For a deterministic encryption scheme, there is a trivial CPA adversary $\\mathscr{A}$: $\\mathscr{A}$ ask $Enc_k(\\cdot)$ to encrypt $m_0,m_1$ first and obtain $c_0&#x3D;Enc_k(m_0), c_1&#x3D;Enc_k(m_1)$. Then when it gets challenge ciphertext $c$, $\\mathscr{A}$ simply compares $c$ to $c_0,c_1$. If $c&#x3D;c_0$, output $0$, and if $c&#x3D;c_1$, output $1$. Also we could see that, for public encryption scheme, EAV-security is equivalent to CPA-security since adversary knows public key $pk$. (equivalent to hold the encryption oracle $Enc_{pk}(\\cdot)$)"},{"title":"完善保密性及其松弛","path":"/wiki/note-cryptography/perfect-secrecy-and-its-relaxation.html","content":"Perfect Secrecy and its RelaxationIf an encryption scheme is perfectly secure, the ciphertext reveals NO additional information to the adversary about the underlying plaintext, even if the adversary has unbounded computational power. Perfect secrecy is the strongest definition of security. Probability Definition $\\Pr[M&#x3D;m|C&#x3D;c]&#x3D;\\Pr[M&#x3D;m]$ for all $m, c$ (perfect indistinguishability) $\\Pr[M&#x3D;m_0|C&#x3D;c]&#x3D;\\Pr[M&#x3D;m_1|C&#x3D;c]$ for all $m_0,m_1,c$ Adversarial Indistinguishability ExperimentEncryption scheme $\\Pi&#x3D;\\langle Gen, Enc, Dec \\rangle$, $Enc$ takes $k, m$ as input (in currying style $Enc_k$), $Dec$ takes $k, c$ as input (in currying style $Dec_k$). Threat model: adversary $\\mathscr{A}$ with unbounded computational power $\\mathscr{A}$ selects 2 plaintexts $m_0, m_1$. Challenger $\\mathscr{C}$ generates a random bit $b\\in{0,1}$, and runs $Enc_k(m_b)\\to c$. $c$ is called the challenge ciphertext and is given back to $\\mathscr{A}$. $\\mathscr{A}$ finally outputs a bit $b’$, indicating that $c$ corresponds to the plaintext $m_{b’}$. $\\mathscr{A}$ successes if $b’&#x3D;b$. Perfect secrecy of $\\Pi$ indicates that NO adversary could success in the above experiment with probability greater than $\\frac{1}{2}$. $\\Pr[\\mathtt{PrivK}^{eav}_{\\mathscr{A}, \\Pi}(n)&#x3D;1]&#x3D;\\frac{1}{2}$. This means that adversary has NO better choice than simply outputting a random guess. Shannon’s TheoremShannon points out that an encryption scheme could be perfectly secure only when $|\\mathscr{K}|\\geq |\\mathscr{M}|$ ($\\mathscr{K}$ is key space, $\\mathscr{M}$ is message space). One-time pad is a typical perfectly secure scheme: adversary can never derive $m$ from a given $c$ if he does not know the secret key $k$. In OTP, $|\\mathscr{K}|&#x3D;|\\mathscr{M}|&#x3D;2^n$. In real life, perfectly secure encryption scheme has little application value: If 2 parties have the ability to safely transmit a key of the same length as the plaintext, then obviously it is better to transmit the plaintext directly. Relaxation: Computational SecrecyThe relaxed definition of perfect secrecy is more frequently used in reality: Polynomial probabilisitic time (PPT) adversary (deprived of unbounded computational power) adversary is allowed to success with negligible advantage It is called asymptotic computational secrecy. (Non-)Negligible advantage is an asymptotic concept. $\\varepsilon(n)$ denotes the negligible probability for a fixed security parameter $1^n$. For example, the probablistic $\\Pr[\\mathtt{PrivK}^{eav}_{\\mathscr{A}, \\Pi}(n)&#x3D;1]\\geq\\frac{1}{2}+\\varepsilon(n)$ indicates that adversary successes in the EAV experiment with non-negligible advantage: $\\Pi$ is EAV-secure. Eureka&nbsp;moment!相信学习过密码学的同学所接触的第一个加密方法都是一次性密码本 One-time pad，这也是最令我惊叹的加密方法之一：其操作是那样的简单优美，只需要将明文和密钥异或起来即可生成密文。 然而，就是这么简单的算法，居然满足完美安全的定义：也就是说，按照 OTP 算法生成的密文 $c$，只要我将密钥 $k$ 彻底销毁，那么全宇宙就没人能够得到其对应的明文 $m$. 即使是拥有无穷算力的超高级文明，也无法获取关于 $m$ 的任何信息，哪怕 $1$ bit 都不行！ 这不禁让我的中二之魂熊熊燃烧…… P.S. 事后我想了想，如果 $m$ 是有意义的一段文字，那么超高级文明得到 $m$ 并不会很难。所以超高级文明永远无法得到我随便乱想的一段乱码 $m$ ! (骄傲)"},{"title":"对称与非对称密钥","path":"/wiki/note-cryptography/symmetric-or-asymmetric-key-s.html","content":"Symmetric or Asymmetric Key(s)The concept of symmetry and asymmetry refers to the keys distribution in 2 parties (sender and receiver). If the information is encoded and decoded with the same key $k$, we say the scheme is symmetric. Otherwise, it is asymmetric. Private Key Encryption and MACPrivate key encryption scheme and message authentication code (MAC) are symmetric primitives. In fact, private key encryption scheme is also called symmetric encryption. Private key encryption: Alice encrypts the message $m$ by running $Enc_k(m)\\to c$. Bob decrypts the ciphertext $c$ by running $Dec_k(c)\\to m$. Message authentication code (MAC): Alice authenticates $m$ by running $Mac_k(m)\\to t$. Bob verifies the tag $t$ by checking $Vrfy_k(m,t)$ equals to $1$ or not. Message Authentication Code (MAC) provides integrity, which ensures that the information is not tampered during transmission. Alice applies the MAC algorithm to $m$ and produces an unforgeable tag $t:&#x3D;Mac_k(m)$. Alice sends the tag $t$ along with the message $m$: Bob then verifies the tag to check whether the message $m$ is tampered or not. Public Key Encryption and Digital SignaturePublic key encryption scheme and digital signature are asymmetric primitives. Public key encryption scheme is also called asymmetric encryption. In asymmetric primitives, the key-generation algorithm $Gen(1^n)$ will produce a pair of keys $\\langle pk, sk \\rangle$. The public key $pk$ is publicly distributed, while private key $sk$ is only held by one party. Public key encryption: Alice encrypts the message $m$ with public key $pk$ by running $Enc_{pk}(m)\\to c$. Bob decrypts the ciphertext $c$ with private key by running $Dec_{sk}(c)\\to m$. Digital signature: Alice signs $m$ with private key by running $Sign_{sk}(m)\\to \\sigma$. Bob verifies the signature $\\sigma$ by checking $Vrfy_{pk}(m, \\sigma)$ equals to $1$ or not. Note that in public key encryption, receriver Bob holds the private key; while in digital signature, sender Alice holds the private key. MAC Versus Digital SignatureMAC and digital signature both provide integrity. However, the asymmetry of digital signature guarentees more than that. Public Verifiability A third party not directly participating in the protocol should also be able to verify the generated values. It is based on the publicity of $pk$. MAC cannot achieve this since $k$ must be kept secret for the defence of a malicious third party. Transferability Non-repudiation Once the signer signs a message $m$, he can NOT deny having done so afterwards. It is based on the secrecy of $sk$: $sk$ is only known by signer and is paired up with $pk$. Anyone with $pk$ could convince that signer holds $sk$ with zero-knowledge of $sk$."},{"title":"归约的概念","path":"/wiki/note-cryptography/the-idea-of-reduction.html","content":"The Idea of ReductionFor problem $A$ and $B$, if there exists a computable function $f$ that for all instance $x\\in A$, $A(x)&#x3D;B(f(x))$, we say that $A$ could reduce to $B$. Reduction (or simulation) is a powerful idea in computer science. Especially in cryptography, we use the idea of reduction to prove security of some cryptographic primitives. We will illustrate the idea of reduction with a concrete example. Example: Pseudo One-time PadPseudo OTP:Pseudo OTP solves OTP’s drawback that secret key $k$ needs to be as long as message $m$.For $m\\in {0,1}^n$, we expand a short key $k$ to the length $n$ with PRG: $r:&#x3D;G(k)$. Pseudo OTP encrypts as $c:&#x3D;m\\oplus G(k)$. Try to prove: Pseudo OTP $\\Pi$ is EAV-secure if $G$ is a PRG. We reduce “Pseudo OTP $\\Pi$ is EAV-secure” to “$G$ is a PRG”. Construct a distinguisher $D$ for $G$ given $\\mathscr{A}$ attacking $\\Pi$ as its subroutine. $D$ runs $\\mathscr{A}(1^n)$. $\\mathscr{A}$ outputs $m_0,m_1$. $D$ generates a random bit $b\\in{0,1}$ and obtain $r$ from PRG challenger. $D$ sends $m_b\\oplus r$ back to $\\mathscr{A}$. $\\mathscr{A}$ finally outputs $b’$. If $b’&#x3D;b$, $D$ outputs $1$, otherwise $0$. reduction&nbsp;flowchart Considering the following 2 cases: $r\\leftarrow U_{n}$ is truly random In this case, the view of $\\mathscr{A}$ is distributed identically to that of a true OTP protocol $\\widetilde{\\Pi}$ which obeys perfect secrecy, therefore $\\Pr_{r\\leftarrow U_{n}}[D(r)&#x3D;1]&#x3D;\\Pr[b&#x3D;b’]&#x3D;\\Pr[\\mathtt{PrivK}^{eav}_{\\mathscr{A}, \\widetilde{\\Pi}}(n)&#x3D;1]&#x3D;\\frac{1}{2}$. $r:&#x3D;G(s)$ for some $s$ ($r$ is pseudorandom) In this case, the view of $\\mathscr{A}$ when run as a subroutine of $D$ is that of the adversarial indistinguishability experiment of the Pseudo OTP $\\Pi$, therefore $\\Pr_{s\\leftarrow U_m}[D(G(s))&#x3D;1]&#x3D;\\Pr[b&#x3D;b’]&#x3D;\\Pr[\\mathtt{PrivK}^{eav}_{\\mathscr{A}, \\Pi}(n)&#x3D;1]$. Reduction process: Since $G$ is PRG: $|\\Pr_{r\\leftarrow U_{n}}[D(r)&#x3D;1]-\\Pr_{s\\leftarrow U_m}[D(G(s))&#x3D;1]|\\leq \\varepsilon(n)$. From the 2 equality above: $|\\Pr[\\mathtt{PrivK}^{eav}{\\mathscr{A}, \\Pi}(n)&#x3D;1]-\\Pr[\\mathtt{PrivK}^{eav}{\\mathscr{A}, \\widetilde{\\Pi}}(n)&#x3D;1]|\\leq \\varepsilon(n)$. Therefore $\\Pr[\\mathtt{PrivK}^{eav}_{\\mathscr{A}, \\Pi}(n)&#x3D;1]\\leq \\varepsilon(n)+\\frac{1}{2}$, which indicates that pseudo OTP is EAV-secure. Reduction LogicReduction provides an abstraction. Understand the abstraction is the key to understand reduction. If we want to reduce the security of $\\Pi’$ to the security of $\\Pi$, we need to construct an adversary $\\mathscr{S}$ for $\\Pi$ given the adversary $\\mathscr{A}$ for $\\Pi’$ as its subroutine, which is to say, $\\mathscr{S}$ employs (runs) $\\mathscr{A}$ as a black box abstraction function (Encapsulation). The reduction involves 4 logic statements: $p:$ $\\exists\\ \\mathscr{S}$ that is able to attack $\\Pi$ with non-negligible advantage. $q:$ $\\exists \\ \\mathscr{A}$ that is able to attack $\\Pi’$ with non-negligible advantage. $\\lnot p:$ $\\Pi$ is secure, which means $\\mathscr{S}$ that could successfully attack $\\Pi$ is NOT exist. $\\lnot q:$ $\\Pi’$ is secure, which means $\\mathscr{A}$ that could successfully attack $\\Pi’$ is NOT exist. If $\\mathscr{S}$ is constructed successfully, it will be able to attack $\\Pi$ with non-negligible advantage. Therefore we could conclude that if $\\mathscr{A}$ could attack $\\Pi’$ successfully, $\\mathscr{S}$ (which takes $\\mathscr{A}$ as its subroutine) could attack $\\Pi$. The corresponding logic is $q\\to p$. According to the contrapositive statement, we have $\\lnot p\\to \\lnot q$, which implys that the security of $\\Pi$ guarantees the security of $\\Pi’$. Therefore, the reduction is completed: we reduce the security of $\\Pi’$ to the security of $\\Pi$. Contrapositive argument:The contrapositive of the conditional statement “If $p$ then $q$. “ is “If not $q$ then not $p$”.The logical equivalence could be expressed by $p\\to q \\iff \\lnot q\\to \\lnot p$. Eureka&nbsp;moment!归约应该是整个密码学安全性证明中的核心思想之一。 第一次接触归约时 (即上文中提到的对伪一次性密码本安全性的证明) 真的思考了超级久才把整个逻辑捋清。但一旦想明白了就会觉得实在是巧妙：假设攻击方案 $A$ 的敌手存在，我们直接将该敌手封装 (encapsulate) 起来作为攻击已知安全的方案 $B$ 的敌手的子程序 (subroutine)。如果构建成功，根据逆否命题就能完成归约。 归约证明最难的地方应该在于 simulator $\\mathscr{S}$ 的设计：其与子程序 $\\mathscr{A}$ 的交互必须是黑盒式的，且无法让 $\\mathscr{A}$ 察觉到与其互动的并不是 challenger $\\mathscr{C}$，而是某个 simulator $\\mathscr{S}$。 在整个课程的学习中了解到了很多很妙的归约，例如 Pseudorandom function&#x2F;permutation 构建的加密方案的 CPA 安全性证明，Hash-MAC 与 Hash-Sign 方案的安全性证明，Authenticate encryption 的安全性证明，RSA 硬核谓词 (Hard-core predicates) 的证明，RSA-FDH (Full-Domain Hash) signature 的不可伪造性证明，Fiat-Shamir transformation 的证明，Schnorr identification 的安全性证明…… 光是写出来就有一大串，就不具体介绍了 (我有一个绝妙的证明.jpg)"},{"title":"序","path":"/wiki/note-astronomy/index.html","content":"引有两种东西，我对它们的思考越是深沉和持久，他们在我心灵中唤起的赞叹和敬畏就会越来越历久弥新，一个是我们头顶浩瀚灿烂的星空，另一个是我们心中崇高的道德法则。他们向我印证，上帝在我头顶，亦在我心中。 —— 伊曼努尔·康德 我们希望看到的是星空，还是永恒之影？ 最初只是因为这门课没有 group project 才选的，但愈上愈觉有趣，也促成了我第一次完整读完一本英文书。教授非常有热情，课程质量高，一分努力一分好 grade。推荐所有对科学史与科学哲学感兴趣的同学都来上一上。 启中Eng声明：以下内容为作者就有关课程学习期间整理之个人笔记，并不包含、引用或披露任何与该课程作业或考试有关之资料。所有信息仅供个人学习及复习之用。Disclaimer:These notes are the author’s personal study summaries for the course. They do not contain, refer to, or disclose any assignment or examination materials. All information is for individual learning and revision only. 按 课号：CCST9012 教授：Dr. T.D. Wotherspoon &amp; Dr. H.F.D. Yu 讲义：Kwok, S. (2017). Our Place in the Universe."},{"title":"安乐死与协助自杀：课程记录","path":"/wiki/note-moral-dilemma/euthanasia.html","content":"定义安乐死（Euthanasia）：以益人为目的的杀人。医生协助自杀（Physician-Assisted Suicide，PAS）：医生提供能够自杀的方式。 安乐死的种类 自愿安乐死（voluntary euthanasia）：一个人「愿意」被杀。 不自愿安乐死（involuntary euthanasia）：一个人不愿被杀。e.g., 纳粹。 非自愿安乐死（non-voluntary euthanasia）：一个人不具有做出是否被杀决定的能力。e.g., 植物人（vegetative state），重度昏迷者，婴儿等。 此处的「愿意」要求此人展现出以下自主性： 理智（Sound mind&#x2F;Procedurally rational） 知情（Sufficient relevant information） 非胁迫（Not under duress） 主动与被动安乐死主动安乐死（active ~）：你直接采取致使一个人死亡的行为。e.g.，lethal injection。 被动安乐死（passive ~）：你有意的撤除维生措施间接致使一个人死亡的行为。 目前，被动安乐死普遍取得了比主动安乐死更高的接受度。 雷切尔（James Rachels）支持「主动安乐死并不比被动安乐死更不可取（no worse than）」的论述： 若被动安乐死是为了解除病人的痛苦，那么主动安乐死同样如此。 主动致死（killing）与放任死亡（letting die）真的有区别吗？&#x3D;&gt; Smith and Jones 案例。 反驳 1：卡姆（Francis Kamm）认为，如果能够处决凶手复活受害者，那么杀死 Smith 是可接受的，但杀死 Jones 是不可接受的。 激进的推广：反驳 2：我们似乎无时无刻不在放任其他人死亡。我们与谋杀犯一样坏吗？"},{"title":"序","path":"/wiki/note-moral-dilemma/index.html","content":"引上个学期我已经仰望过头顶璀璨的星空了，接下来就让我探索一下内心崇高的道德律令吧！ 这门课同样也没有 group project。不禁让人怀疑这种冥冥的安排究竟是不是康德的大手……！（康德：哈哈，决定论者滚回你的现象界去） 启中Eng声明：以下内容为作者就有关课程学习期间整理之个人笔记，并不包含、引用或披露任何与该课程作业或考试有关之资料。所有信息仅供个人学习及复习之用。Disclaimer:These notes are the author’s personal study summaries for the course. They do not contain, refer to, or disclose any assignment or examination materials. All information is for individual learning and revision only. 名录 伦理学&#x2F;道德哲学Ethics&#x2F;Moral Philosophy 效果论Consequentialism （行为）效益主义&#x2F;功利主义(Act) Utilitarianism 规则效果论Rule Consequentialism 享乐主义Hedonism 自主&#x2F;自决Autonomy 超义务行为Supererogation 康德义务主义Kantianism 格率Maxim 同态复仇Lex talionis 目的王国Kingdom of Ends 杰里米·边沁Jeremy Bentham 约翰·斯图尔特·密尔John Stuart Mill 安乐死Euthanasia 医生辅助自杀Physician-Assisted Suicide (PAS) 按 课号：CCHU9009 教授：Dr. David Birks 助教：Chiu Tak Chow 讲义： Kuhse, H, Singer, P. (eds.) 2015. Bioethics: An Anthology, Blackwell. Shafer-Landau, R. 2010. The Fundamentals of Ethics. Oxford University Press."},{"title":"引子：课程记录","path":"/wiki/note-moral-dilemma/intro.html","content":"真是令人印象深刻的第一堂课。David 确实超级有魅力，能让所有人都心甘情愿地把电脑和手机放到包里。 这门课外国人和 local 都很多（还有参加英辩的），感觉自己那点英文实在不够用啊。这种情况下 group discussion 和外国人组队反而很有优势，因为他们都很喜欢表达，我只要在旁边观察和微笑着附和几句 Yeah、Totally、That’s so true 再提几个无关紧要的问题即可。 破冰经典的电车难题（Trolly Problem）起手。虽然是老掉牙的道德悖论，但 David 引领下的同学们之间的互动还是非常有趣；也让我意识到人与人之间的观点差异原来真的可以这么大。 从这三个问题（经典 Trolly，Trolly with a Fat Man，倒霉的旅人）看来我的道德观念到目前为止还算是 consistent 的，吧？我不会拉操纵杆，不会推胖子，也不会牺牲旅人。同组有一个女生甚至和我的选择完全相反，天哪，某种意义上也是很佩服了。"},{"title":"康德义务主义","path":"/wiki/note-moral-dilemma/kantianism.html","content":"ReadingThe Fundamental of Ethics, Chapter 12, Shafer-Landau Do the right thing because it is right. 人是目的而非手段Principle&nbsp;of&nbsp;HumanityAct in such a way that you treat humanity, whether in your own person or in the person of any other, never merely as a means to an end, but always at the same time as an end. 在康德义务主义中，人是目的而非手段。 具有人性（humanity）意味着同时具有理性（rationality）与自主性（autonomy）。 把某人当作目的（ends），意味着待之以应有的尊重。 把某人当作手段（means），意味着视之为实现其他目的的工具。 理性与自主两个特质赋予人特殊的道德地位与价值。理性告诉我们如何实现目标；自主，即成为自我立法者（self-legislator），使我们能够决定指导我们人生的原则，并承担相应的责任。 康德对这两种特质的推崇，使得我们能够很容易的判断某些行为的善恶，而无需像效益主义那样，计算并衡量它们产生的结果： 奴隶制，强奸，家长主义（paternalism）是恶的 &#x3D;&gt; 伤害了自主 我们相信没有人无可救药 &#x3D;&gt; 我们相信人的自主 我们相信基本人权 &#x3D;&gt; 人权即是从最基础的层面保护理性与自主 我们相信人需要对彼此负责 &#x3D;&gt; 拥有自主意味着对选择与行为负有道德责任 洗脑，药物控制和严刑逼供是恶的 &#x3D;&gt; 即使目标良善，也不可剥夺人的自主 善意志Good&nbsp;WillIt is impossible to conceive anything at all in the world, or even out of it, which can be taken as good without qualification, except a good will. 康德彻底否认了效果论，即幸福或任意形式的福祉决定了最终价值。无论是幸福，财富，知识，勇气；所有这些，只要是通过错误行为获得的，它就没有价值。 他认为，只有一样东西无论在何种情境下都具有道德价值（moral worth），那就是善意志（good will）。善意志有两部分： 知道我们的义务所在。 出于义务本身而履行义务。 如何理解「出于义务本身」？康德说，「善意志，并不因它所促成的事物而善，不因它期望的事物而善，也不因它善于达到预定的目标而善，而仅是由于意愿而善，它是自在的善。」 一个商人对顾客公平，不为赢得声誉或避免惩罚，仅仅因为履行道德义务的意愿，康德认为这才是真正具有道德价值的行动。我们可以从这里清晰地看到康德主义与效益主义的分野。 普遍法则Principle&nbsp;of&nbsp;UniversalizabilityAct only in accordance with that maxim through which you can at the same time will that it become a universal law. 我们如何知道我们的义务所在呢？康德在《形而上学道德基础》（Groundwork of the Metaphysics of Morals, 1785）提出了可普遍化原则（Principle of Universalizability）： 构造格率（formulate the maxim） e.g.，当我缺钱时，我要借钱不还，因为我想解决经济困难。 格率普遍化（universalize the maxim） 如果每个人在该情况下都这样做，世界还能运行吗？这种法则能普遍成立吗？（规则效果论？） 一致性检验（test for contradiction） 矛盾于本质（contradictions in nature）：若普遍化后行为的可能性自相矛盾（如果人人都借钱不还，「借钱」的概念将不存在），那么该格率是道德上不允许的。 矛盾于意志（contradictions in will）：即使逻辑上没有矛盾，理性的人也无法一致的愿意这样的世界存在，那么该格率是道德上不允许的。 任一具有理性的人，都能通过这一原则检验自己的义务。这一过程无须涉及情感（emotions）或欲望（desires）。康德贬低了这两者，将理性置于首位。他否认了休谟「动机生于欲望」的论断，甚至写道：「如果一个合乎义务的行为是由情感或欲望驱动的，它就没有任何道德价值。」这是因为： 情感和欲望是不可靠的道德指导。我们可能因为同情心帮助逃犯，因为愤怒遮蔽公正。 情感和欲望并非「人性」的组成部分，它们不总是受控，并且因人而异；但理性作为一种道德智慧，是每个人都具有的。 意志自律Principle&nbsp;of&nbsp;AutonomyAct so that through your maxims you could be a legislator of universal laws. 我们可以发现可普遍化原则与自主原则（Principle of Autonomy）的表述十分相似。 *「你只应按照你同时能希望它成为普遍法则的格率去行动。」*「你只应按照你同时能使自己成为普世立法者的格率去行动。」 有没有发现区别？前者强调人因具有理性而成为普世守法者（universal law followers），提供形式检验来解决「行为是否道德」的问题，后者强调人因具有自主而成为普世立法者（universal law givers），解决「为什么该道德法则对我有约束力」的问题。 「自律」，即「自我立法」：意志自律的体现，并非它「服从」法则，而是因为它是立法者本身；并且正因如此，它才服从法则。唯有如此，意志才是「善」的，道德价值才能彰显。 目的王国Principle&nbsp;of&nbsp;the&nbsp;Kingdom&nbsp;of&nbsp;EndsAct in accordance with the maxims of a member giving universal laws for a merely possible kingdom of ends. 目的王国原则将意志自律推向了集体层面。所谓的「目的王国」，就是康德设想中的所有理性主体参与自律立法的普遍法则共同体。在目的王国中： 我们的行为与一个理想道德立法机关（ideal moral legislature）的颁布的法则相一致。 该立法机关制定的是普遍性的法则，对包括其自身在内的所有理性意志都具约束力。 共同体中的每一个成员都是普遍法则的立法者。 通过立法的参与，所有成员都被视为目的而非手段，理性意志成为「善意志」。 简单来说，康德认为，如果存在一个共同体，其成员平等参与立法，且所有成员均具有理性；那么我们的根本道德义务就是遵循该共同体（我们也是其中的一部分）所接受的法则。 批判模糊性与可普遍化原则不同，人性原则（人是目的而非手段）显得太过模糊，难以应用。 有些情况下，我们不太清楚将一个人当成「目的」究竟意味着什么。 同态复仇康德认为实现正义是至关重要的。也就是说，人们应当得到他们「正当」的待遇（just deserts），即使这不会给任何人带来好处。 康德支持同态复仇（lax talionis）原则，即，我们应当按照罪犯对待受害者的方式对待罪犯。他声称，这种惩罚把罪犯当作「目的」，给予了罪犯应得的尊重，因为它承认了罪犯的理性与自主（所以，如果罪犯不具有理性或自主，如精神错乱者，就不属于同态复仇的应用范围）。 同态复仇有诸多吸引力，但它无法解决以下这些问题： 意图：你能接受「过失伤人」的罪犯与「故意伤人」的罪犯受到同等的惩罚吗？ 无受害者即无罪：酒后驾车但没伤到任何人的人，应当受到惩罚吗？ 难以应用：劫机犯？绑架犯？我们要让罪犯体验一次被劫机，被绑架吗？这似乎没有意义。 不道德：为了惩罚恶劣的罪犯，我们需要官方雇佣的强奸犯，拷问官，纵火犯吗？ 正义固然重要。但我们应当质疑康德认为为了得到正义须不惜一切代价的观念是否正确。 自主的不可能我们真的「自主」吗？ 《论自主性的反对》（Argument against Autonomy）: 我们的选择要么必然（necessitated），要么不必然。 如果是必然的，那么它们就不受我们控制，因此我们没有自主性。 如果是不必然的，那么它们就是随机的，因此我们没有自主性。 因此，我们没有自主性。 「必然」的行动代表着它有原因。由于这些原因成熟了，行动才必然发生。一个必然的行动看似是我们自主的选择，但追溯其原因链条，我们最终一定会到达一个「不自主」之处（基因遗传，社会影响，成长经历等）。既然原因决定了行动，又存在一个不自主的原因决定了后续的一系列原因，那么我们的行动终究是不自主的。 「不必然」的行动代表着它没有原因。它的出现纯粹基于偶然；而既然没有任何因素导致这一选择，那么我们也可以认为这一选择是不受主体本身控制的，因而也是不自主的。 前提 1 显然是正确的，值得讨论的是前提 2 和 3。这直接衍生出哲学的一个子版块 —— 自由与决定论 —— 在此按下不表。 道德运气假设我们的确拥有自主。康德认为，道德评价必须针对一个人可控的部分，即其自主能够决定的部分。但在现实生活中，我们的道德评价似乎会受到「运气」（moral luck）的影响，而这是我们无法掌控的。 少年时期在乡间小路上飙车，若平安无事，多年以后可能会成为温情的回忆；但若导致瘫痪事故，将会遭受长久的谴责。 按照康德的理论，道德运气不存在。行为的善恶判断应遵循可普遍化原则，与其产生的结果无关。我们能够想象即使没有任何事故发生，康德也会谴责这种行为。 重要的事，康德可能是对的！既然如此，我们就得修正一系列已经存在的道德评价体系；但这有时会显得过于严苛。 道德共同体的范围与效益主义不同，康德用「具有理性和自主」这一标准来划定道德共同体的范围，这天然的排除了动物，「边缘人类」，甚至婴儿。 《论动物的反对》（Argument against Animal）： 若人性原则为真，则动物没有权利。 若动物没有权利，则虐待动物是道德上可接受的。 因此，若人性原则为真，则虐待动物是道德上可接受的。 虐待动物是道德上不可接受的。 因此，人性原则为假。 显然我们的康德是很爱动物的（He who is cruel to animals become hard also in his dealing with men），他同意前提 4。针对前提 2，他提出了两个站不住脚的反驳。 反驳 1：虽然动物没有权利，但虐待动物会使得我们的心灵变得冷漠无情，进而影响到我们对待其他人的方式，而人是有权利的。因此，我们不该虐待动物。 &#x3D;&gt; 驳回：哈哈，康德呀康德，你开始通过一个行为的「后果」来判断其善恶了。但你理论的根基不就是这二者无关吗？效益主义者听了你的驳论会很开心的。另外，既然人高于动物，那么假设人会把对待动物的方式迁移到对人身上也是不合理的。 反驳 2：伤害动物就是伤害它的主人的权利，因此不能伤害动物。 &#x3D;&gt; 驳回：这个就更难以服人了。野生动物又如何呢？「边缘人类」又如何呢？如果主人想要虐待他自己的宠物，难道就是允许的吗？ 由此可见，在道德共同体的范围这一点上，效益主义（所有「能受苦」的个体都属共同体）做的比康德主义更好。"},{"title":"我们为何谈论道德主张","path":"/wiki/note-moral-dilemma/realist-faq.html","content":"ReadingThe Realist F.A.Q., Thomas Sinclair, 这篇小文回答了一些常见的针对伦理学的意义问题。择几个我最有共鸣的做一下记录。 权威性的来源？疑问 1：我们不应干涉他人的生活方式；这不是你/我/他能够评判（judge）的。 &#x3D;&gt; 回答：这就相当于说，干涉他人的生活方式是「错」的，或，评判他人是「错」的；而这本身就是一种道德主张（moral claim）！伦理学研究的就是这样的问题：为什么干涉他人的生活方式是「错」的？如果人人都不干涉他人的生活方式，社会能变得更好吗？ 疑问 2：谁有权「决定」道德主张是否正确？ &#x3D;&gt; 回答：简短的回答，「你」有权决定。复杂的回答：这和「决定」无关。我们不会去问谁能「决定」某个数学公式是否正确，因为真就是真，假就是假；在政治哲学&#x2F;伦理学领域，情况是一样的。我们所做的是试图运用逻辑来发现道德主张是否为真。 真的存在？疑问 1：没有所谓的客观真理（objective truth，or Truth）。 &#x3D;&gt; 回答：真的本质是一个深刻的哲学问题，但我们先不讨论那些。这句话的意思是：既然没有客观真理，我们不应（或不必要）讨论道德主张的真与假。这实际上仍然是一个道德主张。 并且，假设「没有所谓的真理」为真，那它就不是真的；如果它为假，那么它是假的。我们似乎能够通过逻辑发现这一论述为假。 所有声称「没有真理」的人都没能说出任何真实的东西；如果仅仅提出这个主张而不能让人信服，那么其就不属于哲学的论述。"},{"title":"行为效益主义之贰","path":"/wiki/note-moral-dilemma/utilitarianism-2.html","content":"ReadingThe Fundamental of Ethics, Chapter 10, Shafer-Landau 效益主义的弊病福祉的计算效益主义要求我们在作出抉择时，计算出行为产生的 1) 福祉 2) 痛苦，得到 3) 善恶比，并比较这个行动是否能取得比其他行动更优的善恶比。 但有人反驳，「计算福祉」（同样的，痛苦）从原则上就是不可能的。 首先，我们并不能总是掌握一个行为的所有可能效益；有些行为产生的影响甚至超越了一个人的生命尺度。效益主义者回应，这仅仅说明了我们的道德无知（moral ignorance），如果掌握了足够的信息，至少福祉的计算是可能的。 其次，这一方法论和多元主义的幸福观（pluristic view of well-being）相冲突。后者认为，个人福祉有很多来源，常见的候选包括知识、美德、爱、友谊、幸福、自主等等。 我们该如何计算「爱的程度」，「友谊的程度」？如何又将这些品质加权合成一个总体的个人福祉程度？即使它们能够计算，但不同特质之间真的能够通约（commensurable）吗？ 这些问题能总结为如下的《论价值计算》(Argument from Value Measurement) ： 效益主义为真仅当存在一个精确的计算标准，能够决定某个行动的后果的效益。 该计算标准不存在。 因此，效益主义为假。 效益主义者难以驳斥前提 2（直到现在他们都无法证明这样标准的存在），可以下手的就只有前提 1 了：即，即使我们没有这样的计算标准，效益主义也可以为真。 考虑这两种痛苦：1) 丈夫在孩子面前辱骂妻子 2) 贫民窟爆发了大规模瘟疫。我们虽然无法用精确的标准对这两种恶进行量化，但却能做出第二种痛苦「更大」的判断。也就是说，至少在某些情况下，福祉和痛苦是可比较的；而一旦可以比较，效益主义就仍行之有效。 一招险棋！效益主义没有被推翻：然而以上这些所有问题都能令我们意识到，我们一方面是道德无知的，另一方面，即使能够了解所有行为的结果，我们也难以进行精确的计算与衡量。若如此，效益主义就失去了它最主要的一项优势，即提供具体指导的实用性方面。 苛求的行动指南深思熟虑 deliberation按照效益主义的要求，在做决定之前，人必须掌握充分的道德知识和卓越的「计算」技巧。 反驳：密尔的经验论：「基督徒无需在每次做决定前都读一遍圣经」。 动机 motivation效益主义以「最大化世界总体福祉」为唯一目标。但人非圣贤，我并不想在做出每个决定之前都得考虑我的行动是否「最优」。 妥协：的确如此。并且效益主义者承认，真正怀抱这一目标的个体反而常常失败。一个思考的角度是将决策过程（decision procedure）与正确性标准（standard of rightness）区别开。 效果论首先是一种正确性标准。它关注的是合理性，旨在解释某个行动为何、在何时被认为是「正确」的。而效益主义所遵循的效益原则（principle of utility）是基于效果论的决策过程，用于指导具体行动。重点在于，一种正确性标准不一定是一个好的决策过程。 行动 action即使我们真正了解到能够「最大化世界总体福祉」的那个行动，我们又为何要去做呢？而效益主义认为，这是一个人「应当」去做的。 显然，我能确信现在将我的零花钱全部捐给 UNICEF 能够增加世界总体福祉，如果选择回应效益主义的要求，我这辈子都别想去旅游了。 对于超义务（supererogation）的行为，如，冲入火场救出动弹不得的儿童，我们通常认为这值得高度的赞扬，但并非必要；而效益主义则认为，既然这一行动能够增加总体福祉，那么它也是我们的道德责任。换句话说，超义务在效益主义中不存在。 反驳：效益主义者承认效益主义者对人的道德要求过于苛刻；但这并不构成反驳效益主义作为一种道德理论的理由。事实上，它挑战既得利益者的舒适，可能正是它真实性的标志。 公平性之前提过，公平性是效益主义的优势之一，试想百万富翁和街边乞丐的福祉重要并同等重要，这一信条是多么美好！ 但，代价是什么呢？ 「公平性」在道德共识中似乎并不放之四海而皆准。我爱我的孩子甚于你的孩子，我爱我的朋友甚于陌生人，我爱我的邻人甚于大洋彼岸的人。如果我的孩子犯了牙疼，我会将钱用来送他去看医生而不是捐给遭受饥荒的儿童；这非常自然，但前者带来的总体福祉却远小于后者。 效益主义是否会判定这样的行动为不道德呢？ 反驳：效益主义者认为，这一行动不是不道德的，但并非我的孩子比贫困儿童「更重要」，而是因为将钱捐给遭受饥荒的儿童从长期来看也许会比送孩子去看牙造成更多的痛苦（自己的孩子会认为父母不重视自己，从而导致长期的发展阻碍；而遭受饥荒的儿童与我素不相识，也不会因为我「不捐献」这件事造成更大的伤害）。 通过这种论述，效益主义者说，更关注与自己亲近的人实际上是更能增加总体福祉的。 但公平性的问题不仅如此。由于我们必须平等计算所有人的福祉，试想在一个社会中，几乎所有人都对一个小型少数群体存在根深蒂固的偏见，并以此为奴隶制辩护。 如果遵循效益主义的原则，在作决定时，我们不仅要考虑被奴役者所受的痛苦，也要考虑奴役者的快乐。这就不可避免地导向「多数人的暴政」—— 如果有足够多的人保持刻薄和愚昧，那么效益主义将可能站在压迫者一方。 本质善恶的模糊 For utilitatians, the morality of an action always depends on its results. This feature of the theory is precisely what supports its moral flexibility: any sort of action can be morally right, so long as its outcome is optimific. 效益主义的道德灵活性同样也有其另一面，那就是行为本质善恶的界限被模糊了。我们倾向于认为，杀人，强奸，奴役这些行为，从本质上就是「恶」的；效益主义则不苟同「本质恶」的概念，因为一个行为的善或恶，与其本身无关。 想象这样一个人，他没有亲近之人，生活如同行尸走肉，未来黯淡，整日与抑郁相伴。他仍然想活下去，并偶尔能获得一点微小的快乐；但就整体而言，他是痛苦的，并且比绝大多数人都痛苦，我们知道这一情形不会改变。 这个人的生命本身降低了总体福祉，如果他死了，世界上的痛苦将会减少。因此，假若我们能在不造成更多痛苦的前提下杀死他（如，伪造死因为自然死亡并不被任何人发现），我们就完成了效益主义提出的道德要求。 这不是谋杀，而是正当杀人（justifiable homicide），正如在极端情况下食用人的尸体一样。为了「最大化福祉」，没有什么禁忌是绝对的。 如何，你能接受吗？ 事实上，许多犯下罄竹难书罪行的人都曾以类似的逻辑为自己辩护。我们深知他们的虚伪，但以效益主义的角度看，其中也有某种程度的真实。故事总是类似：没错，我们不完美；但我们所做的都是为了大多数。就算推翻我们，你确定会有更好的结果吗？ 效益主义否认了任何行为可能具有的内在善或内在恶；这就是拥有道德灵活性的代价。 直到作恶者的步履开始沉重 「听着，这不是童话世界，」效益主义者们说，「我们可能不得不与邪恶合作，为了最小化造成的痛苦。」在这里，也许「意图」能够更好的帮助我们做出判断。这些话语所表达的，是对总体福祉的真切关注，还是逃避责任的自我安慰？ 非正义 It’s true that, when rights are violated, victims are usually harmed. So utilitariansim usually condemns injustice. But not always. 在这里，我们将「正义」定义为对权利（rights）的尊重；反之非正义则是对权利的侵犯。效益主义要求我们，即使行为非正义，只要它是最优的，我们就应当采用；对于很多人来说，这是难以接受的。 比如说，执法者通过威胁、关押甚至惩罚犯罪分子的亲人，能够有效的迫使其自投罗网。如果这样能够增进总福祉，效益主义认为可以接受。但这一行为侵犯了无辜的人的权利，是非正义的。 二战后美国遮掩了纳粹科学家的罪行，因为他们愿意分享战争科技；执法人员承诺释放罪犯，如果他们愿意透露有关头目的情报；中饱私囊的政治家能够安享晚年，仅仅因为追责可能会带来更大的社会动荡 —— 我们对这些非正义的事件一点也不陌生。效益主义将受害者的痛苦与「总体福祉」放在天秤上衡量后，将它们视为道德上善的。 一个可行的道德理论，应当给予「正义」应有的重要性；但效益主义在这方面似乎并不令人满意。反对者们藉此提出另一个论述《论非正义》Argument from Injustice： 正确的道德理论不会要求我们采取严重非正义的行动。 效益主义有时要求我们采取严重非正义的行动。 效益主义并非正确的道德理论。 反驳 1：将「正义」同样纳入本质善。但这样我们回到了面对多元主义幸福观的困局。 反驳 2 => 前提 2：「非正义」的行为一定不是「最优」的。这本质上又是一种采取「道德无知」回应的策略。找到反例并不难：我们不得不承认，有时非正义之举能够达成最好的结果。 反驳 3 => 前提 1：「正义」的牺牲有时是必要的。这也许是最适合效益主义者的宣言了。毕竟，从效益主义诞生之初，它就做好了与主流意见背离的准备。"},{"title":"行为效益主义之壹","path":"/wiki/note-moral-dilemma/utilitarianism-1.html","content":"ReadingThe Fundamental of Ethics, Chapter 9, Shafer-Landau 效益主义的本质效果论Consequentialism says that an action is morally required just because itproduces the best overall results (i.e., is optimific). 效果论（Consequentialism）的唯一标尺即如上所述，通过「结果」来评判行动的好坏。而「结果」的计算方式是本质善（intrinsically good）减去本质恶（intrinsically bad），因此，获得最佳善恶比的行动是最优的（optimific）。 效果论者追求将世界变得更好。 行为效益主义效果论是一系列结果至上的道德理论的集合；它们因对本质善与本质恶定义的不同而区别开来。在这里我们关注效果论中一个最流行的理论，行为效益主义（Act Utilitarianism），或简称的效益主义。 效益主义将本质善定义为福祉（well-being），本质恶定义为糟糕的处境（faring poorly）；还是不太明显？没关系，密尔（John Stuart Mill）在享乐主义的基础上作了进一步定义：快乐（happiness）是福祉，而痛苦（misery）是糟糕处境。 为了达成效果论「将世界变得更好」的目标，效益主义者要求世界中的总体福祉得到最大化。这种福祉是可以计算和比较的。 行为与意图 Utilitarians think there is no essential connection between the morality of an action and the morality of the intentions behind it. 效果论有一个显而易见的重要问题：在抉择行动时，结果是没有发生的。枪杀一个陌生人显然带来了痛苦，那么假若此人是未来的希特勒，这一行为是否潜在的带来了更多的福祉？释放一个承诺改过自新的罪犯带来了福祉，那么如果他出狱后本性不改，又犯下了连环杀人案呢？ 在这一问题上，效益主义者分成了两派，大多数人支持事实结果（actual results）决定论，其余的支持期望结果（expected results）决定论。 事实结果决定论听上去很客观，但考虑这样一个例子：我出于好心将在路边摔倒的老奶奶扶起来，之后她过马路时一辆大运撞过来，惨剧发生了；但假如我对老奶奶选择无视，她自己站起来的时间差会让她从死神掌心侥幸逃脱。 即使是最冷血的效益主义者也无法在这种情况下谴责我，毕竟我的意图（intention）是善的。 为了弥补这一缺漏，效益主义者采用了行为意图二分的准则：当意图善而结果恶时，效益主义者承认此人本身不应当受到谴责，但其行为仍然是恶的（非我错，但我做错了）；反之亦然。 效益主义的优越性效益主义之所以受人欢迎是因为它具有一些非常适应如今社会的优越之处。 公平性效益主义信条的根基就是公平（impartiality）。 具体来说，效益主义认为所有人的福祉都重要且同等重要，不论贫富、人种、性别还是信仰。这种平等观念在现在看来似乎理所当然，但在早期效益主义者的时代却显得相当激进。 杰里米·边沁（Jeremy Bentham）在其著作《道德与立法原则概论》（Principles of Morals and Legislation, 1781）中首次完整的论证了效益主义，其本人是坚定的废奴主义者（abolitionist）。他的教子密尔，写下了性别平等领域最早且最有影响力的著作之一《论妇女的从属地位》（The Subjection of Women, 1869）。 对传统道德共识的适应性在证明现当代的基本道德共识方面，效益主义比其他道德理论做得更好。 我们谴责抢劫，强奸，羞辱无助者，杀害无辜者；赞美诚实，守诺，济贫扶弱者，临危不惧者；效益主义不仅和我们的看法高度一致，还提供了这种道德共识之形成的可能解释：一种性格特质之所以是美德，仅仅是因为它倾向于促进增加社会福祉的行为。反之亦然。 人们倾向于选择一种能和自己已有的道德体系兼容，并提供正当性的道德理论。显然没有任何理论能做到十全十美，但效益主义在这方面的得分相当高。 实用性由于效益主义仅有「最大化福祉」这一个终极规则，我们会发现在解决具体道德冲突时它能够给到行之有效的建议。 考虑一个情境：有人一直在你朋友的背后说他坏话。你知道始作俑者，但也清楚他是因为喜欢你的朋友，一时冲动才做出了不恰当的行为；并且，你还知道，出于愧疚，他将会停止这种举动。你的朋友向你询问你是否听说有关他的谣言：你应该坦诚吗？ 不妨假设事件背后没有隐情，效益主义者会选择隐瞒来最大化福祉：当然，这包括朋友与散播流言者的福祉（我们由此可见效益主义经常被抨击「不近人情」的端倪）。 在更大的社会议题上，情形多变复杂，结果也很难预测。效益主义削减相互冲突的主张，直接给出「最大化福祉」的建议。当然，找到「最大化福祉」的具体政策当然很难，但至少效益主义提供了一个方向；这就相当于赢了一半。 灵活性 For utilitarians, no moral rules (other than the principle of maximizing well-being) is absolute. It is morally okay to violate any rules, if doing so will raise overall well-being. 现实社会存在很多道德禁忌，如食人（cannibalism），折磨他人，杀害无辜者等等。效益主义者认为，在某些特殊情境下（如 Donner Party），触犯这些禁忌以最大化福祉的行为并不是道德败坏的体现。 我们大多数人都知道道德规则必须允许某些例外，但问题是如何划界？效益主义同样用「最大化福祉」给出了答案，这也使得它成为了一个具有道德灵活性的理论。 《沉没意志》中的司徒宁是一个典型的效益主义者 道德共同体的范围 the question is not Can they reason, nor Can they talk, but Can they suffer.Jeremy Bentham 道德共同体（moral community）是道德理论应用的范围，在这一共同体内部的成员对彼此负有道德义务。 效益主义者认为，所有能够受苦（suffer）的个体都属于道德共同体，这当然也包括了动物。因此，虐待动物的行为在绝大多数情境（即，不增加总体福祉的情境）下都是不道德的。 将动物囊括在道德共同体中是一个很有争议性的主张。效益主义者通过《论边缘案例》（The Argument from Marginal Cases）论证了他们的观点： 如果，杀害、食用「边缘人类」（”marginal” human-beings）或对他们进行残忍的科学实验是不道德的，那么以同样的方式对待非人类动物（non-human animals）也是不道德的。 杀害、食用边缘人类或对他们进行残忍的科学实验（几乎）总是不道德的。 因此，杀害、食用非人类动物或对它们进行残忍的科学实验也（几乎）总是不道德的。 这里的「边缘人类」定义指的是心理生活水平不高于我们日常食用或实验的非人类动物的人类个体，比如说严重脑损伤、极端智力障碍等等个体。效益主义者这一论证的核心思想在于，这些人类并不比我们在农场或实验室中伤害的动物更有道德重要性，而既然两者同样重要，就必须同等对待。 需要注意的是，效益主义者将动物纳入道德共同体，并不代表他们都是素食者。这是一个很微妙的问题：虽然效益主义强调道德共同体内的个体平等，但在大多数情况下，一个人所能感受到的痛苦与快乐的程度远比一只动物深刻，因此人的「效益权重」比动物的更高。效益主义者认为这并非「物种歧视」，而是对客观感受能力差异的承认。"},{"title":"规则效果论","path":"/wiki/note-moral-dilemma/rule-consequentialism.html","content":"ReadingThe Fundamental of Ethics, Chapter 10, Shafer-Landau 规则效果论规则效果论（Rule Consequentialism）采取了一种妥协的方式，保留了效益主义的大部分精神，又能够应对多项针对效益主义的反对意见。 规则效果论认为，一项行为在道德上正确，仅当它被一条最优社会规则（optimific social rule）所要求。那么如何确立一条最优社会规则？ 这就是「效果论」体现的地方了：如果该社会规则的实行能够使得社会的总体福祉最大化，那么它就是最优的。 又回到福祉的定义。为了解决效益主义忽视正义的问题，胡克（Brad Hooker）将他的版本（同样也是最知名的版本）的规则效果论的内在善定义为幸福与正义。最优的社会规则将能最大化两者。 正义的回归我们来看看规则效果论是如何处理效益主义的一些困境的。 针对执法者通过威胁犯罪分子亲人的方式迫使其就范的例子，考虑这两条社会规则： 执法者无权对无辜人士施压，即使他们是犯罪分子的亲属。 执法者有权对无辜人士采取措施，只要这样能够加速办案进程。 在贯彻第二条社会规则的社会中，我们能够想象执法者被赋予了过多的执法权；他们很有可能对是否需要采取此类措施做出错误的判断。也许在某些孤立案例中，此举是最优的；但作为一项普遍规则，禁止这种行为才是最优的。 简而言之，规则效果论就相当于：「如果人人都像你这样做，我们的社会将变成什么样子！」 这也是为什么，即使马路空无一车，我们也通常不会贸然闯红灯 —— 显然，此时无视交通信号的行动能够增加福祉（为我们节省了一点时间）；但若「不等红灯」成为了一条普适的社会规则，你能想象交通会混乱成何种程度吗？ 本质善恶的可能引入规则同样使得行为的本质善恶成为可能。这是因为，根据规则效果论，有些行为是绝对禁止的，即使有时它们能够带来好结果。 比如说，在此时此地拷问眼前的这名囚犯是最优的，但考虑到存在「禁止拷问」的最优社会规则，我们不能这么做。即使拷问能为我们当前的案例带来好结果，但从多数与长期的角度来看，禁止拷问的社会在幸福和正义两方面可能都比允许拷问的社会好得多。 这样，我们就有充分的理由说，拷问，拘捕无辜之人，食尸，谋杀均是绝对禁止的。这也从某种程度支持了我们认为它们本质上就是恶的道德惯性。 简单的正确规则效果论舍弃了效益主义复杂的预测，计算与权衡。 最优社会规则一旦确立，我们只要遵守即可。 这是一件好事吗？谁有权力确立「最优社会规则」呢？ 批判规则效果论有如此显而易见的好处，愿意接受它的哲学家却不多。斯马特（J. J. C. Smart）更是直接斥之为对规则的非理性崇拜（irratioal rule worship）。 重点在于这个「非理性」。我们知道效果论的目的在于使得结果最优；但规则效果论要求我们服从外部的道德规则，即使我们知道打破它们能够带来更好的结果。明知行为与目的相悖，但仍然盲从，这不就是「非理性」吗？ 效益主义者对规则效果论最严苛的批评 很自然的想法：规则效果论适合作为统治大多数人的道德工具，只有少数人才能藉由效益主义的信条让世界变得更好 —— 这种二分是否催生了一种道德精英主义？"},{"title":"序","path":"/wiki/note-art-history/index.html","content":"引启中Eng声明：以下内容为作者就有关课程学习期间整理之个人笔记，并不包含、引用或披露任何与该课程作业或考试有关之资料。所有信息仅供个人学习及复习之用。Disclaimer:These notes are the author’s personal study summaries for the course. They do not contain, refer to, or disclose any assignment or examination materials. All information is for individual learning and revision only. 名录 博雅教育Liberal arts education 先锋派Avant-garde 按 课号：ARTH1001 教授：Prof. Greg M. Thomas 助教：Ms. Alice Farmer 阅读： Adams, Laurie Schneider. A History of Western Art. 4th ed. 2008. Davies, Penelope J. E., Frima Fox Hofrichter, Joseph Jacobs, Ann M. Roberts, and David L. Simon, eds. Janson’s Short History of Art. 2009. Fineberg, Jonathan. Art Since 1940: Strategies of Being. 3rd ed. 2011. Foster, Hal, Rosalind Krauss, Yve-Alain Bois, Benjamin H. D. Buchloh, and David Joselit. Art Since 1900: Modernism, Antimodernism, Postmodernism. 2nd ed. 2011. Kemp, Martin, ed. The Oxford History of Western Art. 2000. Kleiner, Fred S. Gardner’s Art through the Ages: A Concise Western History. 2nd ed. 2010. Stokstad, Marilyn, and Michael W. Cothren. Art: A Brief History. 5th ed. 2012. Thomas, Greg M. Understanding Western Art through Culture (從文化角度認識西方藝術). 2009. Wilkins, David G., Bernard Schultz, and Katheryn M. Linduff. Art Past Art Present. 6th ed. 2009."},{"title":"西方艺术之源","path":"/wiki/note-art-history/origin.html","content":"艺术与意义 art is thought, not beauty or “mimesis”（摹仿） art communicates in the world, creating community art communicates beyond the world, creating spiritual communion 艺术的历史诠释：四维度 the physical presence of the object: materal, form, effect the triangle of meaning: patron, maker, audience the circle of context: individuals’relationship to society &amp; environment the vector of time: viewing &amp; interpreting from different contexts 史前艺术 Prehistoric art普遍的装饰性（the universality of ornament）&#x3D;&gt; 带有花纹的陶器 神秘性如祭祀，崇拜等（magical function） &#x3D;&gt; Venus of Willendorf（维伦多夫的维纳斯）, Lascaux（拉斯克洞窟） Venus of Willendorf, 可能与早期的地母神崇拜有关 描绘宇宙论（cosmology）如天体运行，历法等；早期的建筑（early architecture） &#x3D;&gt; Stonehenge（巨石阵） 古美索不达米亚艺术美索不达米亚（Mesopotamia）即两河流域（底格里斯 Tigris 和幼发拉底 Euphrates）地区，诞生了苏美尔（Sumerians），阿卡德（Akkadians），古巴比伦（Old Babylonian），亚述（Assyrians）等早期人类文明。 古埃及艺术"}]