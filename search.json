[{"title":"Day 1","path":"/diary-break/db-day-1/","content":""},{"title":"Stellar 魔改小记录","path":"/adapt-stellar/","content":"趁着开学事情不多，好好折腾了一下这个新玩具主题，简直有点到爱不释手的地步了。记录一下魔改的过程，以供自鉴；如果能帮到有类似需求的朋友们就更好啦！ 你好 Stellar！ 博客组织方式之我思众所周知 Stellar 最吸引人的特性之一是强大的 Wiki 文档系统，但一番操作发现并不是所有的文章都适合用 Wiki 进行组织。 向 Wiki 项目中添加文章的过程有点繁琐，得改目录树。 Wiki 项目中的文章居然不在主页显示！即是说假如我的某篇得意之作被收录在 Wiki 项目里，我就无法在主页展示出来；这要求我必须在我的强迫症和虚荣心中舍彼取此。当然有一个方法是项目 wiki/[project] 里收录一篇，再复制一篇到主页 _post，但这个解法实在是太丑陋。 某些主题不明确的文章不适合收到一个集子里。本来打算是专门弄一个「其他」项目，但仔细想想假以时日这个「其他」一定会膨胀到难以忽视。 我仔细审视了一下我的博客内容，大概分成四类。 从左到右从上往下分别记为 A/B/C/D 类型内容 首先 A 型内容很适合做成 Wiki 项目。一方面它们已经成型，后续的增补内容很少；另一方面它们大多数是作为有机整体的课程笔记系列，不太有机会需要单拎一篇出来放到主页。 而 B 型内容多数是散乱的课程笔记/自学记录，质量良莠不齐，显然我想要展示一部分，隐藏一部分；但被隐藏的内容并不代表没有价值，我还是需要挂在博客上供我自己参考回顾，只是我个人并不是特别满意罢了。 C 型内容是我的读书/观影/游戏记录，以时间为经连缀起我的精神生活碎片，显然是需要不断增补更新的。并且这其中有一些认真写的书评&#x2F;影评&#x2F;游戏评，是我想放在主页上展示的。 最后的 D 型内容是我日常的一些文字随笔，没有特定主题，也无需时间串联，整个形式是十分随意的，但这一部分却是我很想展示在主页的内容。 哇！简直乱糟糟！不仅每种内容的组织形式不同，结构完整度不同，我想要展示的欲望也不同！而当中仅仅只有需求 A 是原生 Stellar 可以解决的！如果谁能想到办法四个需求一次满足的话，那 TA 一定是天才了吧！ 我们需要「专栏」！还好！Stellar 提供了一种有别于 Wiki 项目的简化组织形式 —— 专栏，这让我的大业又推进了一步。 简而言之，「专栏」就是没有目录树的 Wiki 项目，其单纯的以时间为索引松散的连缀一系列指定主题的文章。但这同时引入了一个新问题：专栏没有 index 页，每次点进去默认显示的都是最新的文章，而我想要的是一个类似目录或者扉页的东西。 Wiki 项目能够很容易的实现这一点，只要建一个 index 并把它指定为目录树的开头就行。真是成也目录树，败也目录树！ 为了解决这个问题，我定义了一个新的 front-matter 字段：topic_pin： themes/stellar/scripts/events/lib/merge_posts.js1234567891011121314151617181920for (let tid of Object.keys(topic.tree)) &#123; let topicObject = topic.tree[tid] const pinnedPages = topicObject.pages.filter( page =&gt; page.topic_pin === true) const normalPages = topicObject.pages.filter( page =&gt; page.topic_pin !== true) if (topicObject.order_by == &#x27;-date&#x27;) &#123; pinnedPages.sort((a, b) =&gt; new Date(b.date) - new Date(a.date)) normalPages.sort((a, b) =&gt; new Date(b.date) - new Date(a.date)) &#125; else &#123; pinnedPages.sort((a, b) =&gt; new Date(a.date) - new Date(b.date)) normalPages.sort((a, b) =&gt; new Date(a.date) - new Date(b.date)) &#125; topicObject.pages = [...pinnedPages, ...normalPages] topicObject.homepage = topicObject.pages[0]&#125; 在专栏中创建一个 index 页，再在 front-matter 中设置 topic_pin: true 就大功告成啦！ ……把思路逆转过来！试着把 B 型内容和 C 型内容用改良后的专栏来组织，效果很好！在此期间还发现一件有趣的事：由于专栏不要求 markdown 文件存储在 _post 之外，收录不收录到专栏并不影响文章本身在主页上的显示。 之前研究 Wiki 项目产生了惯性思维，一直在想怎样把项目内的亮点文章挪到主页来显示；没想到专栏的这个特性使得需求逆转了：现在需要考虑的是如何隐藏某些在主页的非亮点文章了。 等等！这不是我在老博客中使用过的 hexo-hide-posts 插件吗！ 激动的配置好这个插件，隐藏文章 —— 果然没我想象的那么简单。Stellar 的 topic 并不是一个常规的 generator，不能直接写在白名单里；这就是说当我在主页隐藏某个文章的同时，这个文章同时也在专栏中被隐藏了。 好嘛！到头来还是逆转回去了。异议阿里！ 只好想了个折衷的办法，虽然逆转再逆转的思路确实不太优雅，但实现起来却很简洁（毕竟插件把大部分逻辑都抽象好了，不用白不用）： themes/stellar/scripts/filters/topic_hidden_handler.js12345678910111213141516hexo.extend.filter.register(&#x27;before_generate&#x27;, function() &#123; const hexo = this; const PostModel = hexo.database.model(&#x27;Post&#x27;); const allPosts = PostModel.toArray(); const hiddenTopicPosts = allPosts.filter(post =&gt; post.hidden === true &amp;&amp; post.topic &amp;&amp; post.topic.length &gt; 0 ); if (hiddenTopicPosts.length &gt; 0) &#123; hexo.locals.set(&#x27;hidden_topic_posts&#x27;, function() &#123; return hiddenTopicPosts; &#125;); &#125;&#125;); 这个 handler 会在 hexo-hide-posts 作用之前收集所有被 hidden: true 标记的文章，并在之后 merge_posts.js 脚本收集专栏文章的时候返还 hiddenTopicPosts 中对应专栏的隐藏文章。天哪说起来都好绕。 最终效果见我的专栏，你会发现不是所有的专栏文章都会显示在主页上喔。是不是很不错！ 静态 timeline 标签组件化giscus 评论区主题自定义其他想要做的事 O1 完成博客从 NexT.Pisces 到 Stellar 的迁移！ 计划在学期内结束。 正常 40% KR1 定义并实现所有博客内容的组织形式 定义博客内容组织形式新增专栏目录页支持新增专栏文章主页隐藏功能 已完成 100% KR2 迁移旧博客上的所有博文 计划顺序：D &#x3D;&gt; C &#x3D;&gt; B &#x3D;&gt; A 未完成 10% KR3 其他想要的小特性！ 静态 timeline 标签组件化giscus 评论区换成 LXGW 字体加入「开往」独立博客计划为读书/观影/游戏记录页添加类似豆瓣的封面展示集成 hexo-blog-encrypt 插件实现部分贴文的密码访问研究怎样把本地资源远程托管 未完成 10%"},{"title":"序","path":"/review-game/index/","content":""},{"title":"序","path":"/review-film/index/","content":""},{"title":"《人生的智慧》","path":"/review-book/wisdom-of-life/","content":"简评"},{"title":"《自报家门》","path":"/review-book/zibao-jiamen/","content":"简评摘录"},{"title":"《理想国》","path":"/review-book/the-republic/","content":"简评摘录"},{"title":"《众神的战争：希腊神话与西方艺术》","path":"/review-book/zhongshen-dezhan/","content":"简评"},{"title":"《金阁寺》","path":"/review-book/kinkaku-ji/","content":"简评"},{"title":"序","path":"/review-book/index/","content":""},{"title":"explore","path":"/explore/index.html","content":"UN JOUR JE SERAI DE RETOUR PRÈS DE TOI 这里是？茫茫电子之海中最不起眼的一隅；即使是这样的角落也有千千万万个。 但它的的确确完全属于*此人*。 此人是？一个傲慢、冷漠、自我中心、缺乏个性的人。总而言之，是一个*无趣*的人。 那么又有什么必要在这停留呢？简而言之，他正在经历一个十分特殊的阶段：即，他意识到自己有多么的无趣。 我很了解此人，或者说，像他这类的人。他们虽然常常将「我是个普通人」挂在嘴边，但心底里却丝毫不这么觉得。「毕竟，一个真正的普通人怎么会承认自己只是一个普通人呢？」他们会沾沾自喜地反刍自己的谦虚，脸上现出甜腻的傻笑。 你会发现他们生活在镜像迷宫里，每面镜子都照出他们的幻想。傲慢被映成自信，冷漠被映成理智，自私被映成高效，乏味被映成深刻。 你真该看看镜子破碎时他的表情！更好笑的是，他发现自己并不独特这一事件本身，也在无穷的时间内无限的空间里在无数人的身上反复发生，而他只是其中最不起眼的一个而已。 听起来你并不喜欢这个人。恰恰相反。我嘲笑他的愚蠢，却庆幸他的醒悟。 他从某种浑浑噩噩的状态中稍微取得了一点神智（我得说，和他的同龄人相比，这个过程有点太久了），察觉到他一直以来都陷在一个多么可怖而丑陋的泥潭中。而这还只是第一步。会有更多令人绝望的事实等待着他来发现。 我于是邀请你来欣赏他的挣扎。这一定会相当有趣。 并且我几乎可以确信这也是他想要的；他远比自己想象的更需要其他人的认可和关注。不然怎么会写下这一堆矫揉造作的文字，把*我*远远的放置在*他*的位置，再捏造出另外两个人称帮助他面对这个事实？ 我有点受够了。当然，当然，我能理解。你没有义务参与到这出幻想的三人行当中。我承认这非常的莫名其妙。如果我是你，我只会觉得更加困惑和烦躁。作为一个看客，或者只是无意间点进来的人，你不需要经历这些…… 我说过的吧，他的确相当的自我中心，丝毫不顾及其他人的感受。 但也许你会*享受*这些……如果这样的话…… 「这只是你的一厢情愿。这种投射本身就是莫大的冒犯。」 我越界了。我真诚地表示歉意。我能够想象这歉意本身对你而言也无比的诡异。天哪。我又搞砸了。我原本只是想向你介绍这个人的博客而已。我没能守住他膨胀的自我意识，竟让一些影子附在了你身上；而避免发生这种事本来应该是我的责任、我存在于此的理由。 为了弥补，我决定向你介绍一些真正*有趣*的人。他们是这个人的邻人。我可以保证，你会在他们那里找到一些真正的、有教益的乐趣，而不是在这里，在此处，在这个阴暗的台风天吹袭的夜晚，困在我的喃喃自语中，喘不过气………… 回到现实世界！会不会有点用力过猛了？别担心，以上这段文字只是我的胡言乱语而已啦。你也许会有兴趣逛逛下面这些博客；如果想要交换友链，欢迎在这个页面下留言！ 网上邻居 Steevebrine飘过Skyleekqp's worldArca LunarEricSoraJonanthan"},{"path":"/css/giscus-custom.css","content":"@import url(https://gcore.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.7/lxgwwenkaigbscreen.css); @import url(https://gcore.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.7/lxgwwenkaigbscreenr.css); @import url(https://gcore.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.7/lxgwwenkaiscreen.css); @import url(https://gcore.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.7/lxgwwenkaiscreenr.css); html { font-family: 'LXGW WenKai Screen',system-ui,sans-serif !important; text-rendering: optimizelegibility; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } #__next main .link-secondary { text-decoration-line: unset; } #__next main .underline { text-decoration-line: unset; } #__next main .markdown a { text-decoration-line: unset; } main { --primary-default: 5, 92, 55; --bg-default: 246, 246, 247; --color-prettylights-syntax-comment: #6e7781; --color-prettylights-syntax-constant: #0550ae; --color-prettylights-syntax-entity: #8250df; --color-prettylights-syntax-storage-modifier-import: #24292f; --color-prettylights-syntax-entity-tag: #116329; --color-prettylights-syntax-keyword: #cf222e; --color-prettylights-syntax-string: #0a3069; --color-prettylights-syntax-variable: #953800; --color-prettylights-syntax-brackethighlighter-unmatched: #82071e; --color-prettylights-syntax-invalid-illegal-text: #f6f8fa; --color-prettylights-syntax-invalid-illegal-bg: #82071e; --color-prettylights-syntax-carriage-return-text: #f6f8fa; --color-prettylights-syntax-carriage-return-bg: #cf222e; --color-prettylights-syntax-string-regexp: #116329; --color-prettylights-syntax-markup-list: #3b2300; --color-prettylights-syntax-markup-heading: #0550ae; --color-prettylights-syntax-markup-italic: #24292f; --color-prettylights-syntax-markup-bold: #24292f; --color-prettylights-syntax-markup-deleted-text: #82071e; --color-prettylights-syntax-markup-deleted-bg: #ffebe9; --color-prettylights-syntax-markup-inserted-text: #116329; --color-prettylights-syntax-markup-inserted-bg: #dafbe1; --color-prettylights-syntax-markup-changed-text: #953800; --color-prettylights-syntax-markup-changed-bg: #ffd8b5; --color-prettylights-syntax-markup-ignored-text: #eaeef2; --color-prettylights-syntax-markup-ignored-bg: #0550ae; --color-prettylights-syntax-meta-diff-range: #8250df; --color-prettylights-syntax-brackethighlighter-angle: #57606a; --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f; --color-prettylights-syntax-constant-other-reference-link: #0a3069; --color-btn-text: #24292f; --color-btn-bg: rgba(var(--bg-default), 1); --color-btn-border: rgba(var(--bg-default), 1); --color-btn-shadow: 0 1px 0 rgba(var(--bg-default), 1); --color-btn-inset-shadow: inset 0 1px 0 rgba(var(--bg-default), 1); --color-btn-hover-bg: rgba(var(--bg-default), 0.5); --color-btn-hover-border: rgba(var(--bg-default), 0.5); --color-btn-active-bg: rgba(var(--primary-default), 0.2); --color-btn-active-border: rgba(var(--primary-default), 1); --color-btn-selected-bg: rgba(var(--primary-default), 0.15); --color-btn-primary-text: rgb(255 255 255 / 100%); --color-btn-primary-bg: rgba(var(--primary-default), 1); --color-btn-primary-border: rgba(var(--primary-default), 1); --color-btn-primary-shadow: 0 1px 0 rgb(31 35 40 / 10%); --color-btn-primary-inset-shadow: inset 0 1px 0 rgb(255 255 255 / 3%); --color-btn-primary-hover-bg: rgba(var(--primary-default), 0.9); --color-btn-primary-hover-border: rgba(var(--primary-default), 0.75); --color-btn-primary-selected-bg: rgba(var(--primary-default), 1); --color-btn-primary-selected-shadow: inset 0 1px 0 rgb(0 45 17 / 20%); --color-btn-primary-disabled-text: rgb(255 255 255 / 80%); --color-btn-primary-disabled-bg: rgba(var(--primary-default), 0.5); --color-btn-primary-disabled-border: rgba(var(--primary-default), 0.5); --color-action-list-item-default-hover-bg: rgb(208 215 222 / 32%); --color-segmented-control-bg: #eaeef2; --color-segmented-control-button-bg: #fff; --color-segmented-control-button-selected-border: rgba(var(--bg-default), 0.85); --color-fg-default: rgb(60 60 67); --color-fg-muted: rgb(60 60 67 / 75%); --color-fg-subtle: rgb(60 60 67 / 33%); --color-canvas-default: rgb(255 255 255); --color-canvas-overlay: rgb(255 255 255); --color-canvas-inset: rgba(var(--bg-default), 0.85); --color-canvas-subtle: rgba(var(--bg-default), 1); --color-border-default: rgba(var(--bg-default), 0.85); --color-border-muted: rgb(175 184 193 / 20%); --color-neutral-muted: rgb(175 184 193 / 20%); --color-accent-fg: rgba(var(--primary-default), 0.85); --color-accent-emphasis: rgba(var(--primary-default), 0.95); --color-accent-muted: rgba(var(--primary-default), 0.4); --color-accent-subtle: rgba(var(--primary-default), 0.1); --color-success-fg: #1a7f37; --color-attention-fg: #9a6700; --color-attention-muted: rgb(212 167 44 / 40%); --color-attention-subtle: #fff8c5; --color-danger-fg: #d1242f; --color-danger-muted: rgb(255 129 130 / 40%); --color-danger-subtle: #ffebe9; --color-primer-shadow-inset: 0 1px 0 rgba(var(--bg-default), 1), inset 0 1px 0 rgba(var(--bg-default), 1); --color-scale-gray-1: rgb(234 238 242 / 100%); --color-scale-blue-1: rgb(16 185 129 / 15%); /*! Extensions from @primer/css/alerts/flash.scss */ --color-social-reaction-bg-hover: var(--color-scale-gray-1); --color-social-reaction-bg-reacted-hover: var(--color-scale-blue-1); } main .pagination-loader-container { background-image: url(\"https://github.com/images/modules/pulls/progressive-disclosure-line.svg\"); } main .gsc-loading-image { background-image: url(\"https://github.githubassets.com/images/mona-loading-default.gif\"); } .gsc-comment:not(.gsc-reply-box) .gsc-replies { border-radius: unset; } /* Dark mode overrides for giscus (system/browser dark) */ @media (prefers-color-scheme: dark) { main { --primary-default: 20, 222, 155; --bg-default: 22, 22, 24; --color-prettylights-syntax-comment: #8b949e; --color-prettylights-syntax-constant: #79c0ff; --color-prettylights-syntax-entity: #d2a8ff; --color-prettylights-syntax-storage-modifier-import: #c9d1d9; --color-prettylights-syntax-entity-tag: #7ee787; --color-prettylights-syntax-keyword: #ff7b72; --color-prettylights-syntax-string: #a5d6ff; --color-prettylights-syntax-variable: #ffa657; --color-prettylights-syntax-brackethighlighter-unmatched: #f85149; --color-prettylights-syntax-invalid-illegal-text: #f0f6fc; --color-prettylights-syntax-invalid-illegal-bg: #8e1519; --color-prettylights-syntax-carriage-return-text: #f0f6fc; --color-prettylights-syntax-carriage-return-bg: #b62324; --color-prettylights-syntax-string-regexp: #7ee787; --color-prettylights-syntax-markup-list: #f2cc60; --color-prettylights-syntax-markup-heading: #1f6feb; --color-prettylights-syntax-markup-italic: #c9d1d9; --color-prettylights-syntax-markup-bold: #c9d1d9; --color-prettylights-syntax-markup-deleted-text: #ffdcd7; --color-prettylights-syntax-markup-deleted-bg: #67060c; --color-prettylights-syntax-markup-inserted-text: #aff5b4; --color-prettylights-syntax-markup-inserted-bg: #033a16; --color-prettylights-syntax-markup-changed-text: #ffdfb6; --color-prettylights-syntax-markup-changed-bg: #5a1e02; --color-prettylights-syntax-markup-ignored-text: #c9d1d9; --color-prettylights-syntax-markup-ignored-bg: #1158c7; --color-prettylights-syntax-meta-diff-range: #d2a8ff; --color-prettylights-syntax-brackethighlighter-angle: #8b949e; --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58; --color-prettylights-syntax-constant-other-reference-link: #a5d6ff; --color-btn-text: rgb(235 235 245 / 86%); --color-btn-bg: rgba(var(--bg-default), 1); --color-btn-border: rgba(var(--bg-default), 1); --color-btn-shadow: 0 1px 0 rgba(var(--bg-default), 1); --color-btn-inset-shadow: inset 0 1px 0 rgba(var(--bg-default), 1); --color-btn-hover-bg: rgba(var(--bg-default), 0.5); --color-btn-hover-border: rgba(var(--bg-default), 0.5); --color-btn-active-bg: rgba(var(--primary-default), 0.2); --color-btn-active-border: rgba(var(--primary-default), 1); --color-btn-selected-bg: rgba(var(--primary-default), 0.15); --color-btn-primary-text: rgb(255 255 255 / 100%); --color-btn-primary-bg: rgba(var(--primary-default), 0.45); --color-btn-primary-border: rgba(var(--primary-default), 0.5); --color-btn-primary-shadow: 0 1px 0 rgb(27 31 36 / 10%); --color-btn-primary-inset-shadow: inset 0 1px 0 hsl(0deg 0% 100% / 3%); --color-btn-primary-hover-bg: rgba(var(--primary-default), 0.53); --color-btn-primary-hover-border: rgba(var(--primary-default), 0.75); --color-btn-primary-selected-bg: rgba(var(--primary-default), 0.45); --color-btn-primary-selected-shadow: inset 0 1px 0 rgb(0 45 17 / 20%); --color-btn-primary-disabled-text: rgb(255 255 255 / 80%); --color-btn-primary-disabled-bg: rgba(var(--primary-default), 0.5); --color-btn-primary-disabled-border: rgba(var(--primary-default), 0.5); --color-action-list-item-default-hover-bg: rgb(177 186 196 / 12%); --color-segmented-control-bg: rgb(110 118 129 / 10%); --color-segmented-control-button-bg: #0d1117; --color-segmented-control-button-selected-border: rgba(var(--bg-default), 0.85); --color-fg-default: rgb(235 235 245 / 86%); --color-fg-muted: rgb(235 235 245 / 60%); --color-fg-subtle: rgb(235 235 245 / 50%); --color-canvas-default: rgb(30 30 32 / 100%); --color-canvas-overlay: rgb(30 30 32 / 100%); --color-canvas-inset: rgba(var(--bg-default), 0.85); --color-canvas-subtle: rgba(var(--bg-default), 1); --color-border-default: rgba(var(--bg-default), 0.85); --color-border-muted: rgb(175 184 193 / 20%); --color-neutral-muted: rgb(175 184 193 / 20%); --color-accent-fg: rgba(var(--primary-default), 0.85); --color-accent-emphasis: rgba(var(--primary-default), 0.95); --color-accent-muted: rgba(var(--primary-default), 0.4); --color-accent-subtle: rgba(var(--primary-default), 0.1); --color-success-fg: #3fb950; --color-attention-fg: #d29922; --color-attention-muted: rgb(187 128 9 / 40%); --color-attention-subtle: rgb(187 128 9 / 15%); --color-danger-fg: #f85149; --color-danger-muted: rgb(248 81 73 / 40%); --color-danger-subtle: rgb(248 81 73 / 10%); --color-primer-shadow-inset: 0 1px 0 rgba(var(--bg-default), 1), inset 0 1px 0 rgba(var(--bg-default), 1); --color-scale-gray-7: rgb(22 22 24 / 100%); --color-scale-blue-8: rgb(16 185 129 / 15%); /*! Extensions from @primer/css/alerts/flash.scss */ --color-social-reaction-bg-hover: var(--color-scale-gray-7); --color-social-reaction-bg-reacted-hover: var(--color-scale-blue-8); } main .pagination-loader-container { background-image: url(\"https://github.com/images/modules/pulls/progressive-disclosure-line-dark.svg\"); } main .gsc-loading-image { background-image: url(\"https://github.githubassets.com/images/mona-loading-dark.gif\"); } }"},{"title":"序","path":"/wiki/note-astronomy/index.html","content":"引有两种东西，我对它们的思考越是深沉和持久，他们在我心灵中唤起的赞叹和敬畏就会越来越历久弥新，一个是我们头顶浩瀚灿烂的星空，另一个是我们心中崇高的道德法则。他们向我印证，上帝在我头顶，亦在我心中。 —— 伊曼努尔·康德 我们希望看到的是星空，还是永恒之影？ 最初只是因为这门课没有 group project 才选的，但愈上愈觉有趣，也促成了我第一次完整读完一本英文书。教授非常有热情，课程质量高，一分努力一分好 grade。推荐所有对科学史与科学哲学感兴趣的同学都来上一上。 启中Eng声明：以下内容为作者就有关课程学习期间整理之个人笔记，并不包含、引用或披露任何与该课程作业或考试有关之资料。所有信息仅供个人学习及复习之用。Disclaimer:These notes are the author’s personal study summaries for the course. They do not contain, refer to, or disclose any assignment or examination materials. All information is for individual learning and revision only. 按 课号：CCST9012 教授：Dr. T.D. Wotherspoon &amp; Dr. H.F.D. Yu 讲义：Kwok, S. (2017). Our Place in the Universe."},{"title":"基本原语","path":"/wiki/note-cryptography/cryptographic-primitives.html","content":"Cryptographic PrimitivesCryptographic primitives are well-established, low-level cryptographic algorithms that are frequently used to build cryptographic protocols for computer security systems. In this course, 7 kinds of cryptographic primitives are covered: Encryption scheme Message authentication code (MAC) Hash function Key-exchange protocol Identification scheme Digital signature One-way function In different application scenarios, we need different kinds of security: Confidentiality: only trusted party could understand the secret message. Secure encryption scheme provides confidentiality. Integrity: ensures the information has NOT been tampered in transmission. MAC and digital signature provide integrity. Non-repudiation: sender can NOT later deny that the message was sent. Digital signature provides non-repudiation. Authenticity, Public verifiability, transferability… Also, for a cryptographic primitive, the definition of security varies in face of different threat model. Threat model consists of the adversary and his targets of attack.In stronger notions of security, adversary tends to have more power, therefore cryptographic primitives with stronger definitions are more secure than weak ones. In general, the security of a cryptographic primitive is defined by an experiment (or game). The idea of reduction (归约) is critical in designing such experiments. Encryption scheme: Passive eavesdropping (EAV) security, Chosen-plaintext-attack (CPA) security, Chosen-ciphertext-attack (CCA) security, Perfect secrecy Message authentication code (MAC): Extentially unforgeable under a chosen-message attack Hash function: Preimage resistance, Second-preimage resistance, Collision resistance Key-exchange protocol: EAV security Identification scheme: EAV security Digital signature: Extentially unforgeable under a chosen-message attack One-way function: Non-invertibility"},{"title":"序","path":"/wiki/note-cryptography/index.html","content":"引这一学期糊里糊涂选到了 CS 的高阶课 COMP3357，虽然死了很多脑细胞，但是学到了很多。加密学很有意思，Ravi 讲的很好，TA Zhang Chengru 也很认真负责，上起来很有实感。 之前的笔记 (这里) 太全面肯定不会再仔细看了，于是想趁暑假做一个 digest，让未来的自己也能回忆起一些有趣的，令人大呼巧妙 (Eureka!) 的内容。 我打算将 digest 分为 3 parts，p1 将主要介绍加密学概念中的有趣内容；p2 则侧重于数学 (数论，群论) 等知识在加密学中的应用；p3 是对 p2 的延申，将会介绍加密学中的困难问题 (hard problems) 与单向函数 (one-way function)，其与 p2 中的相关知识存在密切的联系。 启中Eng声明：以下内容为作者就有关课程学习期间整理之个人笔记，并不包含、引用或披露任何与该课程作业或考试有关之资料。所有信息仅供个人学习及复习之用。Disclaimer:These notes are the author’s personal study summaries for the course. They do not contain, refer to, or disclose any assignment or examination materials. All information is for individual learning and revision only. 按 课号：COMP3357 教授：Dr. Ravi. Ramanathan 助教：Zhang Chengru 讲义：Introduction to Modern Cryptography (2nd edition), Katz, J. &amp; Lindell, Y., (2015), CRC Press"},{"title":"柯克霍夫原则","path":"/wiki/note-cryptography/kerckhoff-s-principle.html","content":"Kerckhoff’s PrincipleKerckhoff’s principle is the concept that a Cryptographic system should be designed to be secure, even if all its details, except for the key, are publicly known. Kerckhoff’s principle indicates that the unknowability of secret key $k$ is critical to ensure the security of cryptographic primitive. This principle also makes the storage and transmission of keys extremely important. Eureka&nbsp;moment!第一次学习柯克霍夫定律的时候确实有点惊艳的感觉：一个安全的加密方案竟然必须建立在其所有细节向敌手暴露的前提之下。尽管看上去有点反常识，仔细想想却是有道理的；如果连加密方案本身都需要进行保密，那它的应用价值将大大减少，更遑论加密算法的标准化与通用化了。 而且由此可见现在流行的加密方案都是久经考验的：想象一下，由于算法的所有细节都是公开的知识，一定会有无数人尝试去破解；一个加密方案能够稳定的存在，这一事实本身就能证明其安全性。"},{"title":"完善保密性及其松弛","path":"/wiki/note-cryptography/perfect-secrecy-and-its-relaxation.html","content":"Perfect Secrecy and its RelaxationIf an encryption scheme is perfectly secure, the ciphertext reveals NO additional information to the adversary about the underlying plaintext, even if the adversary has unbounded computational power. Perfect secrecy is the strongest definition of security. Probability Definition $\\Pr[M&#x3D;m|C&#x3D;c]&#x3D;\\Pr[M&#x3D;m]$ for all $m, c$ (perfect indistinguishability) $\\Pr[M&#x3D;m_0|C&#x3D;c]&#x3D;\\Pr[M&#x3D;m_1|C&#x3D;c]$ for all $m_0,m_1,c$ Adversarial Indistinguishability ExperimentEncryption scheme $\\Pi&#x3D;\\langle Gen, Enc, Dec \\rangle$, $Enc$ takes $k, m$ as input (in currying style $Enc_k$), $Dec$ takes $k, c$ as input (in currying style $Dec_k$). Threat model: adversary $\\mathscr{A}$ with unbounded computational power $\\mathscr{A}$ selects 2 plaintexts $m_0, m_1$. Challenger $\\mathscr{C}$ generates a random bit $b\\in{0,1}$, and runs $Enc_k(m_b)\\to c$. $c$ is called the challenge ciphertext and is given back to $\\mathscr{A}$. $\\mathscr{A}$ finally outputs a bit $b’$, indicating that $c$ corresponds to the plaintext $m_{b’}$. $\\mathscr{A}$ successes if $b’&#x3D;b$. Perfect secrecy of $\\Pi$ indicates that NO adversary could success in the above experiment with probability greater than $\\frac{1}{2}$. $\\Pr[\\mathtt{PrivK}^{eav}_{\\mathscr{A}, \\Pi}(n)&#x3D;1]&#x3D;\\frac{1}{2}$. This means that adversary has NO better choice than simply outputting a random guess. Shannon’s TheoremShannon points out that an encryption scheme could be perfectly secure only when $|\\mathscr{K}|\\geq |\\mathscr{M}|$ ($\\mathscr{K}$ is key space, $\\mathscr{M}$ is message space). One-time pad is a typical perfectly secure scheme: adversary can never derive $m$ from a given $c$ if he does not know the secret key $k$. In OTP, $|\\mathscr{K}|&#x3D;|\\mathscr{M}|&#x3D;2^n$. In real life, perfectly secure encryption scheme has little application value: If 2 parties have the ability to safely transmit a key of the same length as the plaintext, then obviously it is better to transmit the plaintext directly. Relaxation: Computational SecrecyThe relaxed definition of perfect secrecy is more frequently used in reality: Polynomial probabilisitic time (PPT) adversary (deprived of unbounded computational power) adversary is allowed to success with negligible advantage It is called asymptotic computational secrecy. (Non-)Negligible advantage is an asymptotic concept. $\\varepsilon(n)$ denotes the negligible probability for a fixed security parameter $1^n$. For example, the probablistic $\\Pr[\\mathtt{PrivK}^{eav}_{\\mathscr{A}, \\Pi}(n)&#x3D;1]\\geq\\frac{1}{2}+\\varepsilon(n)$ indicates that adversary successes in the EAV experiment with non-negligible advantage: $\\Pi$ is EAV-secure. Eureka&nbsp;moment!相信学习过密码学的同学所接触的第一个加密方法都是一次性密码本 One-time pad，这也是最令我惊叹的加密方法之一：其操作是那样的简单优美，只需要将明文和密钥异或起来即可生成密文。 然而，就是这么简单的算法，居然满足完美安全的定义：也就是说，按照 OTP 算法生成的密文 $c$，只要我将密钥 $k$ 彻底销毁，那么全宇宙就没人能够得到其对应的明文 $m$. 即使是拥有无穷算力的超高级文明，也无法获取关于 $m$ 的任何信息，哪怕 $1$ bit 都不行！ 这不禁让我的中二之魂熊熊燃烧…… P.S. 事后我想了想，如果 $m$ 是有意义的一段文字，那么超高级文明得到 $m$ 并不会很难。所以超高级文明永远无法得到我随便乱想的一段乱码 $m$ ! (骄傲)"},{"title":"伪随机性","path":"/wiki/note-cryptography/pseudorandomness.html","content":"PseudorandomnessRandomness is a very important concept in cryptography (and not only in cryptography). Although the concept of randomness is often mentioned, what exactly is randomness and how is it implemented? Our understanding of the concept of “randomness” cannot be separated from the physical phenomena in real life. For example, the sequence of numbers obtained by rolling a six-sided die multiple times is clearly “random”; this randomness, guaranteed by physical experiments, is called True randomness. True random number generation is technically demanding and inefficient: a true random number generator (TRNG) must rely on some random external physical phenomenon as the information entropy resource, such as the trajectory of the user’s mouse movement, thermal noise from resistors and oscillators, computer hardware noise, etc. NO pure algorithms could achieve true randomness.Here, pure algorithms are the algorithms that only use designed mathmatical formulaes or precalculated tables to produce number suquence. TRNGs that generate random numbers with the help of external physical phenomenon is inefficient. Only pure algorithm could meet the requirement of producing many numbers efficiently. Therefore, the concept of pseudorandomness is put forward: Pseudorandom numbers are numbers that appear random. Pseudorandom number generators (PRGs) are the generators that efficiently generate pseudorandom number sequence. PRG takes a short seed $s$ and produces a pseudorandom string $G(s)$. Pseudorandomness is the relaxation of true randomness.We could say that pseudorandomness is equivalent to true randomness in probablistic polynomial time (PPT) background. How to define “appear random”? There are several PPT statistical tests that used to check whether a number sequence is statistical independent or not. If a number sequence could pass all the statistical tests, it is regarded as random, no matter it is generated by TRNGs or PRGs. Essentially, pseudorandom number sequence (or say PRGs) is deterministic : for a fixed seed $s$, $G(s)$ always remains the same. However, if an adversary observing $G(s)$ without knowing the seed $s$, he can NOT distinguish $G(s)$ from a truly random number sequence $r$ with non-negligible advantage. We could see that in the definition of PRGs: $G$ is a PRG if for every PPT distinguisher $D$, $|\\Pr_{s\\leftarrow U_n}[D(G(s))&#x3D;1]-\\Pr_{r\\leftarrow U_{p(n)}}[D(r)&#x3D;1]|\\leq \\varepsilon(n)$. Note that $p(n)$ is the expansion factor of PRG: $G$ expands the seed $s$ ($|s|&#x3D;n$) to $G(s)$ ($|G(s)|&#x3D;p(n)$) Eureka&nbsp;moment!伪随机也是我觉得十分巧妙的一个概念。 其实，本质上来说，伪随机和加密十分相似。加密算法通过密钥 $k$ 的不可知性保证密文 $c$ 的不可解读性；而伪随机数生成器则通过种子 $s$ 的不可知性保证生成的数串 $G(s)$ 的 (伪) 随机性。 这也可以说是柯克霍夫定律威力的延伸体现。"},{"title":"随机算法","path":"/wiki/note-cryptography/randomized-algorithm.html","content":"Randomized AlgorithmA randomized algorithm uses a source of (pseudo) randomness as part of its logic. Randomized algorithm, as opposed to deterministic algorithm, mapping the same input to several random outputs. The randomness is guaranteed by some random tapes implemented by TRNGs, PRGs, PRFs or PRPs. Randomized algorithms are essential to build secure cryptographic primitives: in particular, Any CPA-secure encryption scheme must be randomized. Chosen-plaintext attack (CPA): Adversary holds the encryption oracle $Enc_k(\\cdot)$, which means he is able to obtain any ciphertext $c$ for a desired message $m$ without knowing secret key $k$. For a deterministic encryption scheme, there is a trivial CPA adversary $\\mathscr{A}$: $\\mathscr{A}$ ask $Enc_k(\\cdot)$ to encrypt $m_0,m_1$ first and obtain $c_0&#x3D;Enc_k(m_0), c_1&#x3D;Enc_k(m_1)$. Then when it gets challenge ciphertext $c$, $\\mathscr{A}$ simply compares $c$ to $c_0,c_1$. If $c&#x3D;c_0$, output $0$, and if $c&#x3D;c_1$, output $1$. Also we could see that, for public encryption scheme, EAV-security is equivalent to CPA-security since adversary knows public key $pk$. (equivalent to hold the encryption oracle $Enc_{pk}(\\cdot)$)"},{"title":"对称与非对称密钥","path":"/wiki/note-cryptography/symmetric-or-asymmetric-key-s.html","content":"Symmetric or Asymmetric Key(s)The concept of symmetry and asymmetry refers to the keys distribution in 2 parties (sender and receiver). If the information is encoded and decoded with the same key $k$, we say the scheme is symmetric. Otherwise, it is asymmetric. Private Key Encryption and MACPrivate key encryption scheme and message authentication code (MAC) are symmetric primitives. In fact, private key encryption scheme is also called symmetric encryption. Private key encryption: Alice encrypts the message $m$ by running $Enc_k(m)\\to c$. Bob decrypts the ciphertext $c$ by running $Dec_k(c)\\to m$. Message authentication code (MAC): Alice authenticates $m$ by running $Mac_k(m)\\to t$. Bob verifies the tag $t$ by checking $Vrfy_k(m,t)$ equals to $1$ or not. Message Authentication Code (MAC) provides integrity, which ensures that the information is not tampered during transmission. Alice applies the MAC algorithm to $m$ and produces an unforgeable tag $t:&#x3D;Mac_k(m)$. Alice sends the tag $t$ along with the message $m$: Bob then verifies the tag to check whether the message $m$ is tampered or not. Public Key Encryption and Digital SignaturePublic key encryption scheme and digital signature are asymmetric primitives. Public key encryption scheme is also called asymmetric encryption. In asymmetric primitives, the key-generation algorithm $Gen(1^n)$ will produce a pair of keys $\\langle pk, sk \\rangle$. The public key $pk$ is publicly distributed, while private key $sk$ is only held by one party. Public key encryption: Alice encrypts the message $m$ with public key $pk$ by running $Enc_{pk}(m)\\to c$. Bob decrypts the ciphertext $c$ with private key by running $Dec_{sk}(c)\\to m$. Digital signature: Alice signs $m$ with private key by running $Sign_{sk}(m)\\to \\sigma$. Bob verifies the signature $\\sigma$ by checking $Vrfy_{pk}(m, \\sigma)$ equals to $1$ or not. Note that in public key encryption, receriver Bob holds the private key; while in digital signature, sender Alice holds the private key. MAC Versus Digital SignatureMAC and digital signature both provide integrity. However, the asymmetry of digital signature guarentees more than that. Public Verifiability A third party not directly participating in the protocol should also be able to verify the generated values. It is based on the publicity of $pk$. MAC cannot achieve this since $k$ must be kept secret for the defence of a malicious third party. Transferability Non-repudiation Once the signer signs a message $m$, he can NOT deny having done so afterwards. It is based on the secrecy of $sk$: $sk$ is only known by signer and is paired up with $pk$. Anyone with $pk$ could convince that signer holds $sk$ with zero-knowledge of $sk$."},{"title":"归约的概念","path":"/wiki/note-cryptography/the-idea-of-reduction.html","content":"The Idea of ReductionFor problem $A$ and $B$, if there exists a computable function $f$ that for all instance $x\\in A$, $A(x)&#x3D;B(f(x))$, we say that $A$ could reduce to $B$. Reduction (or simulation) is a powerful idea in computer science. Especially in cryptography, we use the idea of reduction to prove security of some cryptographic primitives. We will illustrate the idea of reduction with a concrete example. Example: Pseudo One-time PadPseudo OTP:Pseudo OTP solves OTP’s drawback that secret key $k$ needs to be as long as message $m$.For $m\\in {0,1}^n$, we expand a short key $k$ to the length $n$ with PRG: $r:&#x3D;G(k)$. Pseudo OTP encrypts as $c:&#x3D;m\\oplus G(k)$. Try to prove: Pseudo OTP $\\Pi$ is EAV-secure if $G$ is a PRG. We reduce “Pseudo OTP $\\Pi$ is EAV-secure” to “$G$ is a PRG”. Construct a distinguisher $D$ for $G$ given $\\mathscr{A}$ attacking $\\Pi$ as its subroutine. $D$ runs $\\mathscr{A}(1^n)$. $\\mathscr{A}$ outputs $m_0,m_1$. $D$ generates a random bit $b\\in{0,1}$ and obtain $r$ from PRG challenger. $D$ sends $m_b\\oplus r$ back to $\\mathscr{A}$. $\\mathscr{A}$ finally outputs $b’$. If $b’&#x3D;b$, $D$ outputs $1$, otherwise $0$. reduction&nbsp;flowchart Considering the following 2 cases: $r\\leftarrow U_{n}$ is truly random In this case, the view of $\\mathscr{A}$ is distributed identically to that of a true OTP protocol $\\widetilde{\\Pi}$ which obeys perfect secrecy, therefore $\\Pr_{r\\leftarrow U_{n}}[D(r)&#x3D;1]&#x3D;\\Pr[b&#x3D;b’]&#x3D;\\Pr[\\mathtt{PrivK}^{eav}_{\\mathscr{A}, \\widetilde{\\Pi}}(n)&#x3D;1]&#x3D;\\frac{1}{2}$. $r:&#x3D;G(s)$ for some $s$ ($r$ is pseudorandom) In this case, the view of $\\mathscr{A}$ when run as a subroutine of $D$ is that of the adversarial indistinguishability experiment of the Pseudo OTP $\\Pi$, therefore $\\Pr_{s\\leftarrow U_m}[D(G(s))&#x3D;1]&#x3D;\\Pr[b&#x3D;b’]&#x3D;\\Pr[\\mathtt{PrivK}^{eav}_{\\mathscr{A}, \\Pi}(n)&#x3D;1]$. Reduction process: Since $G$ is PRG: $|\\Pr_{r\\leftarrow U_{n}}[D(r)&#x3D;1]-\\Pr_{s\\leftarrow U_m}[D(G(s))&#x3D;1]|\\leq \\varepsilon(n)$. From the 2 equality above: $|\\Pr[\\mathtt{PrivK}^{eav}{\\mathscr{A}, \\Pi}(n)&#x3D;1]-\\Pr[\\mathtt{PrivK}^{eav}{\\mathscr{A}, \\widetilde{\\Pi}}(n)&#x3D;1]|\\leq \\varepsilon(n)$. Therefore $\\Pr[\\mathtt{PrivK}^{eav}_{\\mathscr{A}, \\Pi}(n)&#x3D;1]\\leq \\varepsilon(n)+\\frac{1}{2}$, which indicates that pseudo OTP is EAV-secure. Reduction LogicReduction provides an abstraction. Understand the abstraction is the key to understand reduction. If we want to reduce the security of $\\Pi’$ to the security of $\\Pi$, we need to construct an adversary $\\mathscr{S}$ for $\\Pi$ given the adversary $\\mathscr{A}$ for $\\Pi’$ as its subroutine, which is to say, $\\mathscr{S}$ employs (runs) $\\mathscr{A}$ as a black box abstraction function (Encapsulation). The reduction involves 4 logic statements: $p:$ $\\exists\\ \\mathscr{S}$ that is able to attack $\\Pi$ with non-negligible advantage. $q:$ $\\exists \\ \\mathscr{A}$ that is able to attack $\\Pi’$ with non-negligible advantage. $\\lnot p:$ $\\Pi$ is secure, which means $\\mathscr{S}$ that could successfully attack $\\Pi$ is NOT exist. $\\lnot q:$ $\\Pi’$ is secure, which means $\\mathscr{A}$ that could successfully attack $\\Pi’$ is NOT exist. If $\\mathscr{S}$ is constructed successfully, it will be able to attack $\\Pi$ with non-negligible advantage. Therefore we could conclude that if $\\mathscr{A}$ could attack $\\Pi’$ successfully, $\\mathscr{S}$ (which takes $\\mathscr{A}$ as its subroutine) could attack $\\Pi$. The corresponding logic is $q\\to p$. According to the contrapositive statement, we have $\\lnot p\\to \\lnot q$, which implys that the security of $\\Pi$ guarantees the security of $\\Pi’$. Therefore, the reduction is completed: we reduce the security of $\\Pi’$ to the security of $\\Pi$. Contrapositive argument:The contrapositive of the conditional statement “If $p$ then $q$. “ is “If not $q$ then not $p$”.The logical equivalence could be expressed by $p\\to q \\iff \\lnot q\\to \\lnot p$. Eureka&nbsp;moment!归约应该是整个密码学安全性证明中的核心思想之一。 第一次接触归约时 (即上文中提到的对伪一次性密码本安全性的证明) 真的思考了超级久才把整个逻辑捋清。但一旦想明白了就会觉得实在是巧妙：假设攻击方案 $A$ 的敌手存在，我们直接将该敌手封装 (encapsulate) 起来作为攻击已知安全的方案 $B$ 的敌手的子程序 (subroutine)。如果构建成功，根据逆否命题就能完成归约。 归约证明最难的地方应该在于 simulator $\\mathscr{S}$ 的设计：其与子程序 $\\mathscr{A}$ 的交互必须是黑盒式的，且无法让 $\\mathscr{A}$ 察觉到与其互动的并不是 challenger $\\mathscr{C}$，而是某个 simulator $\\mathscr{S}$。 在整个课程的学习中了解到了很多很妙的归约，例如 Pseudorandom function&#x2F;permutation 构建的加密方案的 CPA 安全性证明，Hash-MAC 与 Hash-Sign 方案的安全性证明，Authenticate encryption 的安全性证明，RSA 硬核谓词 (Hard-core predicates) 的证明，RSA-FDH (Full-Domain Hash) signature 的不可伪造性证明，Fiat-Shamir transformation 的证明，Schnorr identification 的安全性证明…… 光是写出来就有一大串，就不具体介绍了 (我有一个绝妙的证明.jpg)"}]